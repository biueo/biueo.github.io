<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[激光复习部分知识点总结]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%BF%80%E5%85%89%E5%A4%8D%E4%B9%A0%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简介激光知识点总结 烧孔效应：入射光变强后，通过受激辐射使具有某一速度的气体分子的反转粒子数减少，表现为增益曲线在该激光频率处下降，形成一个“烧孔”，光强越大，“烧孔”越深。因为激光是在谐振腔内往返传播，使具有与上述速度大小相等、方向相反的气体分子的反转粒子数也减少。结果在增益曲线上出现两个对中心频率对称的“烧 孔” 兰姆凹陷：多普勒加宽的单纵模气体激光器，输出功率总是随纵模频率向中心频率的靠近而增大，但是当纵模频率接近中心频率时，由于增益曲线上两个烧孔重叠而使能够受激辐射的粒子数减小，因而光强反而下降，在中心频率出现凹陷，称为兰姆凹陷。 兰姆凹陷稳频原理： 因为兰姆凹陷的原因，在中心频率出会出现一个功率的极小值，当以谱线的中心频率作为参考标准，当激光振荡频率偏离时，输出功率就会有一定增加，即输出一误差信号→通过伺服系统鉴别出频率偏移的大小和方向，输出一直流电压调节压电陶瓷的伸缩来控制腔长→把激光振荡频率自动的锁定在兰姆凹陷中心处。 磁致旋光偏振方向旋转方向与至于磁场方向有关，与光传播的方向无关，磁场固定后光正向传播与反向传播旋转方向相同自然炫光偏振方向与光入射的方向有关。参考文章 共焦腔$TEM_{00}$模式，谐振频率的公式： \nu = q \frac{c}{2nL}所以温度以及折射率的变化会引起频率的飘移为： \frac{\Delta \nu}{\nu} = -\left({ \frac{\Delta L}{L} + \frac{\Delta n}{n} }\right)Q1：一个腔长60cm的氦氖激光器，波长为632.8nm,求可能出现几个纵模？腔长缩短到10cm呢？荧光线宽为1.5GHz。Q2： 30cm长的硬质玻璃管 HE-NE激光器，硬质玻璃线膨胀系数为$\alpha = 4\cdot 10^{-6}/℃$，温度增加一度时，激光的频率飘移量大小（Hz） Answer 1:腔内所满足的纵模频率为： \nu = q \cdot \frac{c}{2nL}可以求得答案分别为：6,1 Answer 2 : \frac{\Delta \nu}{\nu} = -\left({ \frac{\Delta L}{L} + \frac{\Delta n}{n} }\right)\Delta v= v * \alpha= \frac{c}{\lambda}\alpha= 1.89GHz]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django之xadmin配置和后台的美化定制]]></title>
    <url>%2F2018%2F08%2F01%2FDjango%E4%B9%8Bxadmin%E9%85%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E5%8F%B0%E7%9A%84%E7%BE%8E%E5%8C%96%E5%AE%9A%E5%88%B6%2F</url>
    <content type="text"><![CDATA[xadmin配置和后台的美化定制 xadmin环境的安装本文内容的操作环境是Django版本1.9以上，Python2.10。xadmin库的地址在：https://github.com/sshwsfc/xadmin ；可以选择下载安装1python setup.py install 也可以选择利用下面的代码进行安装，1pip install git+git://github.com/sshwsfc/xadmin.git 但是尽量不要用：1pip install xadmin 因为这样安装的xadmin没有此网址提供的xadmin版本新，存在一些问题。安装的时候会顺带将下面这些python库顺带装上。 django&gt;=1.9.0,&lt;2 django-crispy-forms&gt;=1.6.0 django-reversion&gt;=2.0.0 django-formtools&gt;=1.0 httplib2==0.9.2 future six用xadmin替换Django自带的admin 首先在项目的setting.py文件的INSTALLED_APPS中添加下面的字段 123456789101112INSTALLED_APPS = [ #'django.contrib.admin', 注释掉此句，避免冲突 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog',#原有的应用 'xadmin',#需增加的 'crispy_forms',#需增加的 'reversion',#需增加的] 修改原有的admin.py文件将其重命名为adminx.py，下面是应用blog下的model.py文件 12345678from django.db import modelsfrom django.conf import settingsclass Weiyu(models.Model): abstract=models.CharField(max_length=100) # 微语摘要 date_time=models.DateTimeField(auto_now_add=False) # 微语日期时间 content=models.TextField(blank=True,null=True) #微语具体内容 def __unicode__(self): return self.abstract 修改原有的admin.py文件如下：12345678from django.contrib import adminimport xadmin# Register your models here.from blog.models import Weiyuclass WeiyuAdmin(object): # 这里用object 替换所有的admin.ModelAdmin list_display =('abstract','date_time') search_fields = ('abstract','date_time')xadmin.site.register(Weiyu,WeiyuAdmin) #原本是admin.site.register(Weiyu,WeiyuAdmin) 修改主urls.py文件添加下面两个语句即可 12import xadmin# 放在其他import 文件下面xadmin.autodiscover() 最后需要同步一下数据库 1python manage.py migrate 效果对比admin的效果 登录界面 主页面 xadmin的效果 登录界面 主页面 Enjoy It!]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>xadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数码管数字识别]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%95%B0%E7%A0%81%E7%AE%A1%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[创建数码管数字识别的数据集，通过卷积神经网络学习，最终实现能够识别图片中数码管数字的功能 简单数据集的创建提取数字图片数据集的创建主要是通过opencv库的裁剪，以及人工标定的方式去实现。详细如下: 安装OpenCV-python库，pip install OpenCV-python 然后通过对多张张图片（例如下图）中的数字进行提取： 提取数字代码如下：提取图片中数字生成统一标准图片12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#导入相应库import osimport cv2import numpy as mp# 定义一个函数对图片进行膨胀和腐蚀，不同情况需修改特定参数def thresholding_inv(image): kernel_dilate = cv2.getStructuringElement(cv2.MORPH_RECT,(1, 6)) #kernel_erode = cv2.getStructuringElement(cv2.MORPH_RECT,(1, 1)) gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) ret, bin = cv2.threshold(gray, 220, 255, cv2.THRESH_BINARY) #bin = cv2.medianBlur(bin, 3) #bin = cv2.erode(bin,kernel_erode) bin=cv2.dilate(bin,kernel_dilate,iterations = 1) return bin# 读入图片，tt=6 # 样图序号im = cv2.imread('./datasets/img0000%s.png' % tt)# 样图位置，# 处理图片im_th = thresholding_inv(im)# 显示图片cv2.imshow('%s'%tt ,im_th)cv2.waitKey(0)# Find contours in the image_,ctrs, hier = cv2.findContours(im_th.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)# Get rectangles contains each contourrects = [cv2.boundingRect(ctr) for ctr in ctrs]t=tt*10for rect in rects: # Draw the rectangles cv2.rectangle(im, (rect[0], rect[1]), (rect[0] + rect[2], rect[1] + rect[3]), (0, 255, 0), 3) # Make the rectangular region around the digit leng1= int(rect[3]) leng2= int(rect[2]) pt1 = int(rect[1] ) pt2 = int(rect[0] ) roi = im_th[pt1:pt1+leng1, pt2:pt2+leng2] # 生成统一尺寸图片，类似于mnist数据集 roi = cv2.resize(roi, (28, 28), interpolation=cv2.INTER_AREA) #roi = cv2.dilate(roi, (3, 3)) cv2.imshow('roi',roi) cv2.waitKey(1000) # 保存图片至相应路径 cv2.imwrite('./datasets/test2/%s.jpg'%t,roi) t=t+1 手工标定labels这一步很简单，直接创建一个txt格式的文件，按照采集的图片顺序，行号对应图片序号进行标定： 比如我的： 图片和标签对应处理将数据集图片和标签进行一一对应，12345678910111213141516171819202122232425262728293031#导入数据图片，以features命名imgs=os.listdir('./datasets/train/imgs/')# 定义一个排序函数def nu_str(string): return int(string.split('.')[0])# 将文件夹中的文件按照名称数字大小进行排序 能够与labels一一对应imgs.sort(key=nu_str)features_train=[]# 对每一张图片进行处理，主要是将矩阵转化为一个向量，最后将所有图片打包for i in imgs: img=cv2.imread('./datasets/train/imgs/'+str(i),0) #res,img=cv2.threshold(img, 200, 255, cv2.THRESH_BINARY) #img=cv2.copyMakeBorder(img,5,5,5,5,cv2.BORDER_CONSTANT,value=0) #cv2.imshow('3',img) #cv2.waitKey(100) img=img.reshape(28*28)/255 features_train.append(img)features_train=np.array(features_train) # 包含所有图片的一个向量集## labels## 将每一个图片对应的结果转化为one-hot形式储存## 将每一个 # 读取文件所有内容with open('./datasets/train/targets/target.txt','r') as f: tars=f.readlines()# 向量不同位置对应的结果tar_temp=[0,1,2,3,4,5,6,7,8,9,'.']labels_train=[]# 构造one-hot形式的向量集for i in tars: b=np.array([i[0]==str(tar_temp[j]) for j in range(len(tar_temp))])+0 labels_train.append(b) # 一个包含所有结果的向量集（与图片集一一对应） 验证数据集是否匹配123456# 查看数据集与结果是否一一对应，主要看看显示的图片和打印的数字是否一致for i in range(len(features_train)): cv2.imshow('feature',features_train[i].reshape(28,28)) print(np.argmax(labels_train[i])) cv2.waitKey(500) # 单张图片的显示时间ms 训练模型定义模型多重卷积模型，参考TensorFlow文档，直接上代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 定义权重函数工厂函数（批量生产权重的函数，为了方便）def weight_variable(shape,name): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial,name=name)# 定义偏置工厂函数def bias_variable(shape,name): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial,name=name)# 定义卷积矩阵工厂函数def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')# 定义池化层矩阵工厂函数def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME')## 主要有两层卷积运算# 第一层卷积层定义W_conv1 = weight_variable([5, 5, 1, 32],name='w_conv1') # 权重变量b_conv1 = bias_variable([32],name='b_conv1',) # 偏置# 图片输入空间生成,结果空间生成（请求组织先分配好茅坑）x = tf.placeholder("float", shape=[None, 28*28],name="X") # y_ = tf.placeholder("float", shape=[None, 11],name="Y")# 将输入空间重新塑造为28*28*1（1指单通道，-1是指可以随机应变），为了后面的卷积运算 因为输入是一个向量集x_image = tf.reshape(x, [-1,28,28,1]) # 定义卷积矩阵并计算h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)# 定义池化层 h_pool1 = max_pool_2x2(h_conv1)# 第二层卷积层定义W_conv2 = weight_variable([5, 5, 32, 64],name='w_conv2') # 权重变量b_conv2 = bias_variable([64],name='b_conv2') # 偏置h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)h_pool2 = max_pool_2x2(h_conv2)# 经过两次卷积和池化，最后的图片只有7*7了，但是还是不知道他到底是什么鬼，所以再来一个权重矩阵，来算算他到底是什么鬼# 第一个与处理后图片尺寸一样的权重矩阵变量和偏置变量，直接点乘W_fc1 = weight_variable([7 * 7 * 64, 1024],name='w_fc1') b_fc1 = bias_variable([1024],name='b_fc1')h_pool2_flat = tf.reshape(h_pool2, [-1,7*7*64])h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)# keep_prob为了防止过拟合，具体原理我还没看到。。。。keep_prob = tf.placeholder("float",name='keep_prob')h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)# 再来一个矩阵使得其变成一个全连接层，所谓全连接层就是一个向量，之所以要将矩阵化为全连接层# 就是为了使得他通过和再一个权重相乘能够得到和结果维度相同的输出W_fc2 = weight_variable([1024, 11],name='w_fc2')b_fc2 = bias_variable([11],name='b_fc2')# 最后的结果输出为一个向量 和labels相同的维度，y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)# 设置模型格式 ，添加输出的格式进去tf.add_to_collection('yconv',y_conv)saver = tf.train.Saver() 训练模型并保存简单粗暴 上代码里有注释：1234567891011121314151617181920212223242526# 训练模型with tf.Session() as sess: # 设置交叉熵为损失函数 cross_entropy = -tf.reduce_sum(y_*tf.log(y_conv)) # 设置优化参数，采用AdamOptimizer优化方法，比最速下降法更优，能够防止过拟合 train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy) # 判断预测结果和真实结果是否相同 correct_prediction = tf.equal(tf.argmax(y_conv,1), tf.argmax(y_,1)) # 精度 accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float")) # 初始化各个变量 sess.run(tf.initialize_all_variables()) # 迭代训练 for i in range(201): # 随机选取数据进行训练 sample = random.sample(range(len(labels_train)),50) batch_xs=np.array([features_train[i] for i in sample]) batch_ys=np.array([labels_train[i] for i in sample]) # 当是100倍数是保存模型，并且输出当前测试精度，保存路径为相对路径 if i%100 == 0: train_accuracy = accuracy.eval(feed_dict=&#123;x:batch_xs, y_: batch_ys, keep_prob: 1.0&#125;) print ("step %d, training accuracy %g"%(i, train_accuracy)) save_path = saver.save(sess, "./datasets/digit_model/my_digit_model") train_step.run(feed_dict=&#123;x:batch_xs, y_: batch_ys, keep_prob: 0.5&#125;) # 测试整体精度，加载测试集 print ("test accuracy %g"%accuracy.eval(feed_dict=&#123;x: features_test, y_: labels_test, keep_prob: 1.0&#125;)) 模型应用和结果调用模型以及可视化显示模型训练好可以直接使用此代码进行应用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import cv2import numpy as npimport tensorflow as tfimport os# 不支持多行数字识别，以及单行多个小数点的数值识别（单行只能实现字符串识别），# labels的各个位置代表的数字tar_temp=[0,1,2,3,4,5,6,7,8,9,'.'] # 定义一个阈值函数，将数码管部分取出来，根据实际情况进行相应修改，找到最优参数def thresholding_inv(image): # 定义膨胀核心，根据实际情况进行修改 kernel_dilate = cv2.getStructuringElement(cv2.MORPH_RECT,(1, 6))# 1代表横向膨胀，6代表纵向膨胀 ## 腐蚀参数我已经注释掉，根据实际情况选择是否使用 #kernel_erode = cv2.getStructuringElement(cv2.MORPH_RECT,(2, 1)) ## 根据RGB图得到灰度图 gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 灰度图二值化 ret, bin = cv2.threshold(gray, 220, 255, cv2.THRESH_BINARY) ## 对灰度图进行腐蚀，主要是为了分离相近的小数点，如果足够清晰可以不使用腐蚀，我已注释掉 #bin = cv2.erode(bin,kernel_erode) ## 对灰度图进行膨胀 bin=cv2.dilate(bin,kernel_dilate,iterations = 1) return bin# Read the input image## demo 图像在此目录下im = cv2.imread('./datasets/img00004.png') # 还有 1-6 张图 修改最后一个数即可## 二值化处理im_th = thresholding_inv(im)# 显示图片cv2.imshow('im_th',im_th)cv2.waitKey(1000) # 显示1000ms # Find contours in the image 寻找边界集合_,ctrs, hier = cv2.findContours(im_th.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)# Get rectangles contains each contour rects = [cv2.boundingRect(ctr) for ctr in ctrs]# 加载训练好的模型，并预测通过with tf.Session() as sess: # 加载模型的结构框架graph new_saver = tf.train.import_meta_graph('./datasets/digit_model/my_digit_model.meta') # 加载各种变量 new_saver.restore(sess,'./datasets/digit_model/my_digit_model') yy_hyp = tf.get_collection('yconv')[0] graph = tf.get_default_graph() X = graph.get_operation_by_name('X').outputs[0]#为了将 x placeholder加载出来 keep_prob = graph.get_operation_by_name('keep_prob').outputs[0] # 将keep_prob placeholder加载出来 # mm用来保存数字以及数字坐标 mm=&#123;&#125; # for循环对每一个contour 进行预测和求解，并储存 for rect in rects: # Draw the rectangles 得到数字区域 roi cv2.rectangle(im, (rect[0], rect[1]), (rect[0] + rect[2], rect[1] + rect[3]), (0, 255, 0), 3) # Make the rectangular region around the digit leng1= int(rect[3]) leng2= int(rect[2]) pt1 = int(rect[1] ) pt2 = int(rect[0] ) # 得到数字区域 roi = im_th[pt1:pt1+leng1, pt2:pt2+leng2] # 尺寸缩放为模型尺寸 roi = cv2.resize(roi, (28, 28), interpolation=cv2.INTER_AREA) # 处理成一个向量，为了和模型输入一直 roi=np.array([roi.reshape(28*28)/255]) # 运行模型得到预测结果 pred= sess.run(yy_hyp,feed_dict = &#123;X:roi,keep_prob:1.0&#125;) # 得到最大可能值索引 ind ind=np.argmax(pred) #labels不同位置代表的不同数字 (tar_temp[ind]) 就是预测值 # 将预测值添加到图像中，并显示 cv2.putText(im, str(tar_temp[ind]), (rect[0], rect[1]),cv2.FONT_HERSHEY_DUPLEX, 2, (0, 255, 255), 3) # 储存每个数字和其对应的boundingbox的像素点坐标 mm[pt2]=tar_temp[ind] # 最后的处理 # 根据像素坐标，从左到右排序，得到数字的顺序 num_tup=sorted(mm.items(),key=lambda x:x[0]) # 将数字列表连接为字符串 num=(''.join([str(i[1]) for i in num_tup])) try: numn=float(num) print('图中数字为%s,数值大小为%s' %(num,numn)) except: print('不好意思，目前不支持多个小数点的数值识别') print('图中数字为%s'% num) # 显示图像 cv2.namedWindow("Resulting Image with Rectangular ROIs", cv2.WINDOW_NORMAL) cv2.imshow("Resulting Image with Rectangular ROIs", im) cv2.waitKey(1000) 输出结果输出结果如下图所示： 源码地址https://github.com/biueo/tube_digit_recognization欢迎star]]></content>
      <categories>
        <category>Python</category>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vi最常用到的几个命令]]></title>
    <url>%2F2018%2F07%2F12%2FVi%E6%9C%80%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最常用的VI指令分类 先上一张vi指令的键盘图： 最常用指令集五颗星 命令功能输入法切换到英文输入方可:i 在当前光标处进入插入状态，插入到光标之前a 在当前光标后进入插入状态，插入到光标之后A 将光标移动到当前行的行末，并进入插入状态o 在当前行的下面插入新行，将光标移动到新行的行首，进入插入状态O 在当前行上面插入新航，将光标移动到新行的行首，进入插入状态 编辑功能ZZ 命令模式下保存当前文件所做的修改后退出vi:wq 在命令模式下，执行存盘退出操作:w 在命令模式下，执行存盘操作:w! 在命令模式下，执行强制存盘操作:q 在命令模式下，执行退出vi操作:q! 在命令模式下，执行强制退出vi操作u 撤销最近一次操作，并恢复操作结果，可以多次使用进行多步操作U 取消对当前行进行的所有操作ctrl+r 对使用u命令撤销的操作进行恢复 复制粘贴yy 复制当前行整行的内容到vi缓冲区yw 复制当前光标到单词尾字符的内容到vi缓冲区y$ 复制当前光标到行尾的内容到vi缓冲区y^ 复制当前光标到行首的内容到vi缓冲区 删除操作dd 删除当前光标所在行x 删除光标处的单个字符，连续使用向后删除dw 删除当前字符到单词尾包括空格的所有字符de 删除当前字符到单词尾不包括空格的所有字符d$ 删除当前字符到行尾的所有字符d^ 删除当前字符到行首的所有字符J 删除光标所在行行尾的换行符，相当于合并当前行和下一行内容 最常用vi指令四颗星 搜索功能/word 从上而下搜索文件中查找字符串“word”?word 从下而上在文件中查找字符串“word”n 定位下一个匹配的被查找的字符串N 定位上一个匹配的字符串 替换功能:s/old/new 将当前行中查找到的第一个字符串“old”替换为“new”:s/old/new/g 将当前行中查找到的所有字符串替换为“new”:#,#s/old/new/g 在行号“#，#”范围内替换所有的字符串“old”为“new”:%s/old/new/g 在整个文件范围内替换所有的字符串“old”为“new”:s/old/new/c 在替换命令末尾加入c命令，将对每个替换动作提示用户进行确认 跳转命令Ctrl+u：向文件首翻半屏;Ctrl+d：向文件尾翻半屏;Ctrl+f：向文件尾翻一屏;Ctrl+b：向文件首翻一屏;e或者E 跳转至下个单词行尾b或者B 跳转至上个单词行首0数字0 光标移至当前行首$ 光标移至当前行末H 光标移至屏幕顶行M 光标移至屏幕中间行L 光标移至屏幕最后行G 光标移至最后一行nG 光标移至第n行首n+ 光标下移n行n- 光标上移n行 辅助命令:set nu 显示行号:set nonu 不显示行号]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光纤中的模式]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%85%89%E7%BA%A4%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[光纤中的模式及其兼并度 首先看下图所示，有一个直观了解接着：对于不同的m值（圆周方向电场变化的周期数）会有下面的关系：所以当m值确定时，U的值有很多种情况，（具体和光纤的半径和波长有关系），也能够求出光纤中能够传播的模式数量： M \approx { {1\over 2} {\left({ {2\pi a} \over {\lambda} }\right)^2 {\left({ n_1^2 - n_2^2 } \right)} = { {V^2} \over {2}} }}]]></content>
      <categories>
        <category>老本行</category>
      </categories>
      <tags>
        <tag>激光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清明游记]]></title>
    <url>%2F2018%2F04%2F07%2F%E6%B8%85%E6%98%8E%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[清明节游记 充实的一个清明节，和小胖先后去了三里屯，蓝色港湾，朝阳公园，西单商场。玩了笑傲江湖密室，迷你过山车，照了不错的夜景照片，抓了几个小娃娃，开心充实。附上几张照片。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归和迭代]]></title>
    <url>%2F2018%2F04%2F04%2F%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[迭代和递归的区别 如果说一个过程不调用其他过程，我们称之为叶过程，如果一个程序所有过程都是叶过程，那么整个程序应该很容易理解，但是实际上很多过程会调用其他过程，甚至是调用本身。 递归在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。实现递归理想的数据结构是栈，栈是一种后进先出的队列，它需要一个指针用来指向最新分配的地址，以指示下一个过程放置寄存器的位置，我们称之为栈指针。数据放入为压栈，移除为出栈。以一个例子进行说明： 计算阶乘的递归过程阶乘程序1234int fact(int n)&#123; if(n&lt;1)return(1); else return (n*fact(n-1))&#125; 汇编语言：1234567891011121314151617181920fact: addi $sp, $sp, -8 # adjust stack for 2 items sw $ra,4($sp) # save the return address sw $a0,0($sp) # save the argument nslti $t0,$a0,1 # test for n&lt;1beq $t0,$zero,L1 # if n&gt;=1,go to L1addi $v0,$zero,1 #return 1addi $sp,$sp,8 # pop 2 items off stackjr $ra # return to callerL1: addi $a0,$a0,-1 # n&gt;=1:argument gets(n-1) jar factlw $a0,0($sp) # return from jal:restore argument nlw $ra,4($sp) # restore the return addressaddi $sp,$sp,8 # adjust stack pointer to pop itemsmul $v0,$a0,$v0 #return n*fact(n-1)jr $ra 用fact(3)进行演示 迭代迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值————WiKipedia 举个栗子：123456int sum (int n,int acc)&#123; if(n&gt;0) return sum(n-1,acc+n); else return acc;&#125; 对应的汇编语言12345678sum: slti $t0,$a0,1 # test if n&lt;=0 bne $t0,$zero,sum_exit # go to sum_exit if n&lt;=0 add $a1,$a1,a0 # add n to acc addi $a0,$a0,-1 # subtract 1 from n j sum # go to sumsum_exit: add $v0,$a1,zero # return value acc jr $ra #return to caller]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础数据绘图]]></title>
    <url>%2F2018%2F03%2F08%2Fpython%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[基于matplotlib的数据绘图，基础部分 常用基础绘图12345678910111213141516import matplotlib.pyplot as pltimport numpy as npplt.rc('lines',lw=2) # 设定全局线的宽度plt.rc('font',family='Microsoft YaHei',size=24) #设置全局的字体大小#基本操作x=np.linspace(0,10,100)y=np.sin(x)plt.figure(num=1,figsize=(10,8))plt.plot(x,y,'k-')plt.xlim(0,2*np.pi)plt.ylim(-1,1)plt.xlabel('x轴',fontsize=26)plt.ylabel('y轴',fontsize=26)plt.title('常用基础绘图')plt.grid('true')plt.show() 绘图函数介绍1.函数：plt.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=, clear=False, **kwargs) 关键参数介绍： num : integer or string, optional, default: none If not provided, a new figure will be created, and the figure number will be incremented. The figure objects holds this number in a number attribute. If num is provided, and a figure with this id already exists, make it active, and returns a reference to it. If this figure does not exists, create it and returns it. If num is a string, the window title will be set to this figure’s num. figsize : tuple of integers, optional, default: None width, height in inches. If not provided, defaults to rc figure.figsize. dpi : integer, optional, default: None resolution of the figure. If not provided, defaults to rc figure.dpi. facecolor : the background color. If not provided, defaults to rc figure.facecolor. edgecolor : the border color. If not provided, defaults to rc figure.edgecolor. frameon : bool, optional, default: True If False, suppress drawing the figure frame. FigureClass : class derived from matplotlib.figure.Figure Optionally use a custom Figure instance. clear : bool, optional, default: False If True and the figure already exists, then it is cleared. 返回类型： figure : Figure The Figure instance returned will also be passed to new_figure_manager in the backends, which allows to hook custom Figure classes into the pylab interface. Additional kwargs will be passed to the figure init function. 注释： If you are creating many figures, make sure you explicitly call “close”on the figures you are not using, because this will enable pylabto properly clean up the memory. 设置坐标轴进阶设置坐标轴坐标12345678910plt.figure(num=1,figsize=(8,6))plt.plot(x,y,color='red',linewidth=1.5,linestyle='--') # 绘图plt.xlabel('x轴')plt.ylabel('y轴')plt.xlim((0,10))plt.ylim((-1,1))newticks=np.linspace(0,10,11) # 设置坐标plt.xticks(newticks) # 标注横坐标plt.yticks([-1,0,1],['max','$\\frac&#123;\sqrt&#123;2&#125;&#125;&#123;2&#125;\cdot 0$','min']) # 标注横坐标 可以使用mathjax公式plt.show() 移动隐藏坐标轴12345678910111213141516171819plt.figure(num=1,figsize=(8,6))plt.plot(x,y,color='red',linewidth=3.5,linestyle='--')plt.xlabel('$x$')plt.ylabel('$y=sin(x)$')ax=plt.gca() #获得图像的参数ax.spines['right'].set_color('none') # 隐藏右坐标轴ax.spines['top'].set_color('none') # 隐藏上坐标轴ax.xaxis.set_ticks_position('bottom')# 设置x坐标的位于坐标轴的位置ax.spines['bottom'].set_position(('data', 0)) # data 可以换成outward、axes 移动到y轴data为0的位置ax.yaxis.set_ticks_position('left') # 设置y坐标的位于坐标轴的位置ax.spines['left'].set_position(('data',0)) # data 表示将x轴移动到数据位置0处ax.yaxis.set_tick_params(width=3,length=5)# 设置y坐标轴刻度线尺寸ax.xaxis.set_tick_params(width=3,length=5)# 设置x坐标轴刻度线尺寸ax.spines['left'].set_lw(3) #设置y坐标轴的线的宽度ax.spines['bottom'].set_lw(3)#设置x坐标轴的线的宽度ax.set_xlim(0,10)# ax.spines['left'].set_sketch_params(scale=1.1,length=none) #手绘风格坐标轴#help(ax.xaxis) 查看帮助plt.show() 添加图例12345678910111213141516171819202122232425262728293031323334353637383940414243x=np.linspace(0,10,100)y1=np.sin(x)y2=np.cos(x)plt.figure(3,figsize=(8,6))l1,=plt.plot(x,y1,'r--',label='$sin(x)$') #注意逗号l2,=plt.plot(x,y2,'b',label='$cos(x)$')#注意逗号# plt.xlim()plt.xlim((0,10))plt.ylim((-1,1))#plt.xticks()xticks=np.linspace(1,10,10)plt.xticks(xticks)yrange=np.linspace(-1,1,5)yticks=list(yrange)yticks[0]='$min$'yticks[2]='$zero$'yticks[4]='$max$'plt.yticks(yrange,yticks)#plt.axax=plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.spines['bottom'].set_position(('data',0))ax.xaxis.set_ticks_position('bottom')ax.yaxis.set_ticks_position('left')ax.yaxis.set_tick_params(width=3,length=5)# 设置y坐标轴刻度线尺寸ax.xaxis.set_tick_params(width=3,length=5)# 设置x坐标轴刻度线尺寸ax.spines['left'].set_lw(2) #设置y坐标轴的线的宽度ax.spines['bottom'].set_lw(2)#设置x坐标轴的线的宽度# 图例plt.legend(handles=[l1,l2],labels=['$sin(x)$','$cos(x)$'],loc='best')# 'best' : 0, # 'upper right' : 1,# 'upper left' : 2,# 'lower left' : 3,# 'lower right' : 4,# 'right' : 5,# 'center left' : 6,# 'center right' : 7,# 'lower center' : 8,# 'upper center' : 9,# 'center' : 10,plt.show() 添加标注123456789101112131415161718192021x=np.linspace(-5,5,11) y=xplt.figure(figsize=(8,6))plt.plot(x,y,'b-')ax=plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0))ax.yaxis.set_tick_params(width=3,length=5)# 设置y坐标轴刻度线尺寸ax.xaxis.set_tick_params(width=3,length=5)# 设置x坐标轴刻度线尺寸ax.spines['left'].set_lw(3) #设置y坐标轴的线的宽度ax.spines['bottom'].set_lw(3)#设置x坐标轴的线的宽度plt.plot([3,3],[0,3],'k--',linewidth=2)plt.scatter([3,],[3,],s=50,color='b')plt.annotate(r'$y=x=3$',xy=[3,3],xycoords='data',xytext=(+40,-40),textcoords='offset points',fontsize=24, arrowprops=dict(width=2, connectionstyle="arc3,rad=.3"))plt.text(1.5,3,'$y=x$',fontdict=&#123;'size': 16, 'color': 'r' &#125;)# help(plt.annotate) 查看帮助plt.show() 绘制多图123456789101112131415161718192021222324import pandas as pdwave=pd.read_csv('/Users/ddc/Desktop/1.CSV',names=['wavelength','power'],skiprows=34)x=wave['wavelength']y=wave['power']/-1*max(wave['power'])plt.figure(figsize=(10,8))ax1=plt.subplot2grid((3,3),(0,0),rowspan=2,colspan=2)ax1.plot(x,y)ax1.set_xticks([])ax1.set_title('small figure1')ax2 = plt.subplot2grid((3, 3), (2, 0), colspan=2)ax2.plot(x,y)ax3 = plt.subplot2grid((3, 3), (0, 2), rowspan=2)ax3.plot(x,y)ax3.set_xlim((1010,1050))ax3.set_xticks([])ax3.set_yticks([])ax4 = plt.subplot2grid((3, 3), (2, 2))ax4.plot(x,y)ax4.set_xlim((1010,1050))ax4.set_yticks([])# ax4ax=plt.gca()# ax4ax.spines['right'].set_color('none')plt.suptitle('total') # 总标题plt.show() 123456(figure,((ax11, ax12), (ax13, ax14)))=plt.subplots(2, 2, sharex=True, sharey=True)ax11.plot(x,y)ax12.plot(x,y)ax13.plot(x,y)ax14.plot(x,y)plt.show() 图中图绘制12345678910111213141516171819202122232425262728293031# 导入pyplot模块import matplotlib.pyplot as plt# 初始化figurefig = plt.figure()left, bottom, width, height = 0.1, 0.1, 0.8, 0.8# 创建数据x = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]ax1 = fig.add_axes([left, bottom, width, height])ax1.plot(x, y, 'r')ax1.set_xlabel('x')ax1.set_ylabel('y')ax1.set_title('title')#小图1left, bottom, width, height = 0.2, 0.6, 0.25, 0.25ax2 = fig.add_axes([left, bottom, width, height])ax2.plot(y, x, 'b')ax2.set_xlabel('x')ax2.set_ylabel('y')ax2.set_title('title inside 1')#小图2plt.axes([0.6, 0.2, 0.25, 0.25])plt.plot(y[::-1], x, 'g') # 注意对y进行了逆序处理plt.xlabel('x')plt.ylabel('y')plt.title('title inside 2')plt.show() 次坐标轴12345678910111213141516171819202122import matplotlib.pyplot as pltimport numpy as npx = np.arange(0, 10, 0.1)y1 = 0.05 * x**2y2 = np.sin(x)fig, ax1 = plt.subplots()plt.yticks(color='g')ax2 = ax1.twinx()ax1.plot(x, y1, 'g-') # green, solid lineax11=plt.gca()ax11.spines['left'].set_color('green')ax1.set_xlabel('X data')ax1.set_ylabel('Y1 data', color='g')ax2.plot(x, y2, 'b-') # blueplt.yticks(color='b')ax2.set_ylabel('Y2 data', color='b')ax11=plt.gca()ax11.spines['right'].set_color('b')plt.show()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[儿时]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%84%BF%E6%97%B6%2F</url>
    <content type="text"><![CDATA[我们就天天长大~ 我们就一天天长大。今年二十又四，就步入中年人的行列，本以为这种歌，早唤不起自己日渐麻木的心灵。也不知是深夜的原故，还是残存的感性。听到这首儿时还是被感动的一塌糊涂。童年的种种更像电影般，一幕幕的涌现脑海中。令我，想起了那走过一次次的土泥路，想起了那呆过一天天的老教室，想起了那唱过一遍遍的流行歌；想起了那晚风习习的夏夜，想起了那寒风瑟瑟的冬天，想起了那摸鱼儿的日子，想起了那打雪仗的时光；想起了那弹不完的弹珠，想起了那丢不尽的沙包，想起了那跳不累的皮筋，想起了那玩不腻的小霸王；“日子总是慢的不像话”。想起了那上下课的铃铛声，想起了那抄题成瘾的老师，想起了那一直有聊的同桌；想起了那破烂的新词典，想起了那卯足勇气递出的纸条，想起了曾经喜欢的她。“我们就一天天长大”。想起了那张面孔稚嫩的毕业照，想起了那本字迹褪色的笔记簿，想起了那些日渐走散的发小们，想起了那个后来失去音讯的她，想起了这就是一去不返我的童年啊！]]></content>
      <categories>
        <category>文字</category>
      </categories>
      <tags>
        <tag>瞎写一通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些古诗词]]></title>
    <url>%2F2018%2F02%2F17%2F%E4%B8%80%E4%BA%9B%E5%8F%A4%E8%AF%97%2F</url>
    <content type="text"><![CDATA[诗词几首 终南别业——王维 中岁颇好道，晚家南山陲。兴来每独往，胜事空自知。行到水穷处，坐看云起时。偶然值林叟，谈笑无还期。 &emsp;杳杳寒山道——寒山杳杳寒山道，落落冷涧滨。啾啾常有鸟，寂寂更无人。淅淅风吹面，纷纷雪积身。朝朝不见日，岁岁不知春。 &emsp; 入朝洛堤步月——上官仪脉脉广川流，驱马历长洲。鹊飞山月曙，蝉噪野风秋。 &emsp;白头吟——卓文君凄凄复凄凄，嫁娶不须啼。愿得一人心，白头不相离。 &emsp;咏风——王勃肃肃凉风生，加我林壑清。驱烟寻涧户，卷雾出山楹。去来固无迹，动息如有情。日落山水静，为君起松声。 &emsp;从军行——杨炯烽火照西京，心中自不平。牙璋辞凤阙，铁骑绕龙城。雪暗凋旗画，风多杂鼓声。宁为百夫长，胜作一书生。 &emsp;送别杜审言——宋之问卧病人事绝，嗟君万里行。河桥不想送，江树远含情。别路追孙楚，维舟吊屈平。可惜龙泉剑，流落在丰城。 &emsp;渡汉江——宋之问岭外音书断，经冬复历春。近乡情更怯，不敢问来人。 &emsp;登幽州台歌——陈子昂前不见古人，后不见来者。念天地之悠悠，独怆然而涕下。 &emsp;春江花月夜——张若虚春江潮水连海平，海上明月共潮生。滟滟随波千万里，何处春江无月明。江流宛转绕芳甸，月照花林皆似霰。空里流霜不觉飞，汀上白沙看不见。江天一色无纤尘，皎皎空中孤月轮。江畔何人初见月？江月何年初照人？人生代代无穷已，江月年年只相似。不知江月待何人，但见长江送流水。白云一片去悠悠，青枫浦上不胜愁。谁家今夜扁舟子？何处相思明月楼？可怜楼上月徘徊，应照离人妆镜台。玉户帘中卷不去，捣衣砧上拂还来。此时相望不相闻，愿逐月华流照君。鸿雁长飞光不度，鱼龙潜跃水成文。昨夜闲潭梦落花，可怜春半不还家。江水流春去欲尽，江潭落月复西斜。斜月沉沉藏海雾，碣石潇湘无限路。不知乘月几人归，落月摇情满江树。 &emsp; 摸鱼儿——元好问 问世间，情为何物，直教生死相许？天南地北双飞客，老翅几回寒暑。欢乐趣，离别苦，就中更有痴儿女。君应有语：渺万里层云，千山暮雪，只影向谁去？ 横汾路，寂寞当年萧鼓，荒烟依旧平楚。招魂楚些何嗟及，山鬼暗啼风雨。天也妒，未信与，莺儿燕子俱黄土。千秋万古，为留待骚人，狂歌痛饮，来访雁丘处。 &emsp;临江仙·送钱穆父——苏轼 一别都门三改火，天涯踏尽红尘。依然一笑作春温。无波真古井，有节是秋筠。 惆怅孤帆连夜发，送行淡月微云。樽前不用翠眉颦。人生如逆旅，我亦是行人。 &emsp;]]></content>
      <categories>
        <category>文字</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的Next主题添加相册]]></title>
    <url>%2F2018%2F02%2F17%2Fhexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[hexo的Next主题默认是不含有相册页面的,如果想添加此页面需自行编写 图片的处理 图片需要保存在其他云端，这里为了方便存放在GitHub，首先随便在一个位置创建一个新的文件夹，这里我创建文件夹Blog_Album,然后cd到此文件夹执行，git init在此文件夹内新建一个文件夹/photos 在这里存放需要放的图片。 使用一个Python小脚本对图片进行编辑，并且压缩上传到自己的GitHub，这就需要我们现在GitHub上新建一个Repository,这里命名为Blog_Album, 然后在本地连接远程仓库执行git remote add origin yourrepositroy@gitaddress 然后下载脚本tool.py文件至此文件内，此文件需要Imageprocessing.py文件的支持,可以将此文件保存在你的python3包的安装位置/users/you/anaconda3/lib/python3.6/site-packages/如果没有PIL库的话会报错，安装即可！此外图片命名方式需要按照特定方式即：2017-02-02_discriptionofyourpic.jpg图片支持常见格式，时间和描述之间存在下划线 行tool.py会生成data.json文件，此文件存储了图片的链接，名称和简介，存放位置修改为你的hexo博客主题下特定位置，这里因为是后期加入的相册，所以我在/hexo/themes/next/source/lib中新建一个文件夹album来存放相册文件。所以tool.py生成data.json需要存放在这里。大约在133-134行中进行修改 12345 list_info.reverse() # 翻转 final_dict = &#123;"list": list_info&#125;- with open("/Users/ddc/Desktop/MyBlog/themes/next/source/lib/album/data.json","w") as fp:+ with open("path/to/yourblog/themes/next/source/lib/album/data.json","w") as fp: json.dump(final_dict, fp) 相册页面 在博客根目录下添加photo页面hexo n page photos,在blog的themes的Next中的_config.yml配置文件中menu选项中添加photos: 123456789menu: home: / || home about: /about/ || user categories: /categories/ || th-list tags: /tags/ || tags archives: /archives/ || archive #schedule: /schedule/ || calendar 音乐: /music/ || music+ 相册: /photos || camera 在photos中的index.md添加上下面代码，或者可以直接使用我的index.md只需将里面的博客链接地址修改为你的博客地址即可。 1234567891011121314151617181920212223242526272829---title: 照片date: 2018-2-15 22:32:22type: "photos"fancybox: falsecomments: false---&lt;link rel="stylesheet" href="../lib/album/ins.css"&gt;&lt;link rel="stylesheet" href="../lib/album/photoswipe.css"&gt; &lt;link rel="stylesheet" href="../lib/album/default-skin/default-skin.css"&gt; &lt;div class="photos-btn-wrap"&gt; &lt;a class="photos-btn active" href="javascript:void(0)" target="_blank" rel="external"&gt;Photos&lt;/a&gt;&lt;/div&gt;&lt;div class="instagram itemscope"&gt; &lt;a href="http://www.biueo.com" target="_blank" class="open-ins"&gt;图片正在加载中…&lt;/a&gt;&lt;/div&gt; &lt;script&gt; (function() &#123; var loadScript = function(path) &#123; var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) &#125; setTimeout(function() &#123; loadScript('../lib/album/ins.js') &#125;, 0) &#125;)()&lt;/script&gt; 从index就可以看出我们还需要添加css文件和js文件，这些文件我已经上传到GitHub中地址在这里将这里除了index.md,photoswipe-ui-default.min.js,photoswipe.min.js三个文件的其他文件全部拷贝到前面创建的/hexo/themes/next/source/lib/album中。将photoswipe-ui-default.min.js,photoswipe.min.js两个文件添加到themes/next/source/js/src中。 对ins.js文件进行一个简单的修正，将里面大约在121和122行左右的连接修改为你的GitHub中图片连接地址 1234- var minSrc = 'https://raw.githubusercontent.com/biueo/Blog_Album/master/min_photos/' + data.link[i];- var src = 'https://raw.githubusercontent.com/biueo/Blog_Album/master/photos/' + data.link[i];+ var minSrc = 'https://raw.githubusercontent.com/yougithubname/pathtoyourphotos/min_photos/' + data.link[i];+ var src = 'https://raw.githubusercontent.com/yougithubname/pathtoyourphotos/photos/' + data.link[i]; 确保你的图片地址是正确的，否则加载不出来，检测方法可以将选择一个图片地址看能不能再浏览器中打开。 其他配置上面属于资源的配置，下面是引用配置，在next/layout/_layout.swig的头部&lt;/head&gt;前添加对js文件的引用如下：12&lt;script src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/photoswipe.min.js?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt;&lt;script src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/photoswipe-ui-default.min.js?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt; 在body中添加如下的内容：1234567891011121314151617181920212223242526272829303132333435363738394041&#123;% if page.type === "photos" %&#125; &lt;!-- Root element of PhotoSwipe. Must have class pswp. --&gt; &lt;div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"&gt; &lt;div class="pswp__bg"&gt;&lt;/div&gt; &lt;div class="pswp__scroll-wrap"&gt; &lt;div class="pswp__container"&gt; &lt;div class="pswp__item"&gt;&lt;/div&gt; &lt;div class="pswp__item"&gt;&lt;/div&gt; &lt;div class="pswp__item"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="pswp__ui pswp__ui--hidden"&gt; &lt;div class="pswp__top-bar"&gt; &lt;div class="pswp__counter"&gt;&lt;/div&gt; &lt;button class="pswp__button pswp__button--close" title="Close (Esc)"&gt;&lt;/button&gt; &lt;button class="pswp__button pswp__button--share" title="Share"&gt;&lt;/button&gt; &lt;button class="pswp__button pswp__button--fs" title="Toggle fullscreen"&gt;&lt;/button&gt; &lt;button class="pswp__button pswp__button--zoom" title="Zoom in/out"&gt;&lt;/button&gt; &lt;!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR --&gt; &lt;!-- element will get class pswp__preloader--active when preloader is running --&gt; &lt;div class="pswp__preloader"&gt; &lt;div class="pswp__preloader__icn"&gt; &lt;div class="pswp__preloader__cut"&gt; &lt;div class="pswp__preloader__donut"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"&gt; &lt;div class="pswp__share-tooltip"&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"&gt; &lt;/button&gt; &lt;button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"&gt; &lt;/button&gt; &lt;div class="pswp__caption"&gt; &lt;div class="pswp__caption__center"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endif %&#125; 在/themes/next/layout/_scripts/pages/post-details.swig中添加： 12&lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/photoswipe.min.js?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/photoswipe-ui-default.min.js?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt; 至此所有的配置已经完成。相册应该也能够正常显示了 一些小优化当主题设置fancyboxy为True时，在相册页面存在冲突去掉主题的fancybox所以对/themes/next/layout/_partials/head.swig文件进行修改： 1234567891011121314+&#123;% if page.type === "photos" %&#125;+ &#123;% set theme.fancybox = false %&#125;+&#123;% endif %&#125;+&#123;% if page.type !== "photos" %&#125;+ &#123;% set theme.fancybox = true %&#125;+&#123;% endif %&#125;&#123;% if theme.fancybox %&#125; &#123;% set fancybox_css_uri = url_for(theme.vendors._internal + '/fancybox/source/jquery.fancybox.css?v=2.1.5') %&#125; &#123;% if theme.vendors.fancybox_css %&#125; &#123;% set fancybox_css_uri = theme.vendors.fancybox_css %&#125; &#123;% endif %&#125; &lt;link href="&#123;&#123; fancybox_css_uri &#125;&#125;" rel="stylesheet" type="text/css" /&gt;&#123;% endif %&#125; Enjoy it]]></content>
      <categories>
        <category>Hexo博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[辞旧迎新]]></title>
    <url>%2F2018%2F02%2F15%2F%E8%BE%9E%E6%97%A7%E8%BF%8E%E6%96%B0%2F</url>
    <content type="text"><![CDATA[辞旧迎新总结一下过去一年 &emsp;2017年还剩十几分钟就要过去了，在这除夕之夜兴起总结一下过去一年，大的来说这一年并没有大成，学业还是没有发表一篇paper,没有大的成就，到时迷上了前段和python,系统的学习了python,以及前段部分内容期间基于hexo创建了这个网站。感情方面是这一年最大的收获，4月16号和我的另一半走到了一起。希望一直走下去。突然这么一想还真是想不到什么东西了，看来这一年着实没干多少事情。&emsp;下一年要努力了，不要违背自己当初信仰，天道酬勤。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《PythonCookbook》笔记]]></title>
    <url>%2F2018%2F02%2F11%2F%E3%80%8APythonCookbook%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[python cookbook零碎知识记录 字符串和文本笔记123import re line='asbs fdadf; asdfa, adf,asdf, foo're.split(r'[,;\s]\s*',line) [&#39;asbs&#39;, &#39;fdadf&#39;, &#39;asdfa&#39;, &#39;adf&#39;, &#39;asdf&#39;, &#39;foo&#39;] 注：\s表示空格， 数字日期和时间对数值取整内建函数round(value,ndigits)取整操作，四舍五入，偶数位优先。 ndigits可以取负数，表示取整到十位百位千位。 123print(round(1.25,1))print(round(11.25,-1))print(type(round(11.25,-1))) 1.2 10.0 &lt;class &#39;float&#39;&gt; 如果只是对数值的格式化输出，无需使用round()函数取整，只需输出时进行格式化即可,值得本身并没有变化。 123x=1234.512print(format(x,'0.2f'))print(x) 1234.51 1234.512 精确的小数计算12# 浮点数天生会产生误差比如：print(2.1+3.2) 5.300000000000001 解决方案使用decimal模块 1234from decimal import Decimala=Decimal('3.2')b=Decimal('2.1')print(a+b) 5.3 Decimal对象支持所有常见的数学操作 数值格式化输出使用内建的format函数即可格式化输出：指定宽度和精度的一般格式为：”[&lt;&gt;^]?width[,]?(.digits)?”这里width和digits表示宽度和精度，？表示可选部分。同样的方式可以使用在字符串.format()中。 12345678x=12345.678print('the value is &#123;:0,.2f&#125;'.format(x))print(format(x,'0.2f'))print(format(x,'&gt;10.1f'))# 右对齐print(format(x,'&lt;10.1f'))#左对齐print(format(x,'^10.1f'))#居中对齐print(format(x,',')) # 带有逗号分隔符print(format(x,'0,.2f')) the value is 12,345.68 12345.68 12345.7 12345.7 12345.7 12,345.678 12,345.68 注： 若想使用科学计数法，只需将上述中的f换成e或者E即可 python代码中常用%作为格式符，但是比起format来讲并不是很强大。比如添加千位分隔符。 二进制、八进制、十六进制可以使用内建函数bin(),oct(),hex(),进行数值转换。 123456789101112x=-1234print(bin(x))print(oct(x))print(hex(x))## 如果不希望出现0b,0o,0x字符可以使用format函数print(format(x,'b'))print(format(x,'o'))print(format(x,'x'))##如果希望得到一个无符号数值，需要加上最大值来设置比特位长度比如：print(format(2**32+x,'b'))print(format(2**32+x,'o'))print(format(2**32+x,'x')) -0b10011010010 -0o2322 -0x4d2 -10011010010 -2322 -4d2 11111111111111111111101100101110 37777775456 fffffb2e 注: python语言使用时确保八进制，二进制，十六进制数前面添加0b,0o,0x的前缀。 复数的运算复数可以使用complex(real,imag)来指定，或者通过浮点数添加后缀j来表示 1234a=complex(1,2)b=1+2jprint(a,b)print(a.real,a.imag,a.conjugate())# 取a得实部，虚部以及共轭 (1+2j) (1+2j) 1.0 2.0 (1-2j) 所有常见的数学操作均适用于复数的运算。对于复数的函数操作，比如正弦，余弦等可以使用cmath模块 1234a=1+2jimport cmathprint(cmath.sin(a))print(cmath.sqrt(-1)) (3.165778513216168+1.959601041421606j) 1j 无穷大和NAN首先检测是否出现了这些值，使用math.isinf()和math.isnan()函数进行判断 分数的计算使用fractions模块可以处理设计分数的数学计算 12345from fractions import Fractiona=Fraction(5,4)b=Fraction(7,16)print(a+b)print(a*b) 27/16 35/64 处理大型数组的计算一般使用numpy 随机选择1234567import randomvalue=[1,2,3,4,5]random.choice(value)#从values中随机取出一个元素random.sample(values,2) #从values中随机剔除至2个元素random.shuffle(values)#打乱values元素顺序random.randint(0,10)#从0到10中随机取一个整数random.random()#0到1中取一个浮点数值 更详细的说明参考random库的文档 时间换算主要讲解datetime模块 12345678from datetime import timedeltaa=timedelta(days=2,hours=6)b=timedelta(hours=4.5)c=a+bprint(c.days)print(c.seconds)print(c.seconds/3600)print(c.total_seconds()/3600) 2 37800 10.5 58.5 datetime模块可以创建特定的日期和时间，并使用标准的数学运算来操作他们 123from datetime import datetimea=datetime(2013,11,29)print(a+timedelta(days=10)) 2013-12-09 00:00:00 1234b=datetime(2018,2,14)d=b-aprint(d)print(d.days) 1538 days, 0:00:00 1538 12now=datetime.today()print(now) 2018-02-14 15:08:20.589790 datetime模块是默认处理闰年的 123456a=datetime(2012,3,1)b=datetime(2012,2,28)print((a-b).days)c=datetime(2013,3,1)d=datetime(2013,2,28)print((c-d).days) 2 1 字符串转化为日期12345678910from datetime import datetimetext='2012-2-12'y=datetime.strptime(text,'%Y-%m-%d')z=datetime.now()print(z-y)## 或者速度更快def get_ymd(text): y,m,d=text.split('-') return datetime(int(y),int(m),int(d))print(get_ymd(text)) 2194 days, 16:41:38.444629 2012-02-12 00:00:00]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派穿透校园网下载文献]]></title>
    <url>%2F2018%2F02%2F06%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BF%E9%80%8F%E6%A0%A1%E5%9B%AD%E7%BD%91%E4%B8%8B%E8%BD%BD%E6%96%87%E7%8C%AE%2F</url>
    <content type="text"><![CDATA[使用树莓派穿透校园网，实现非校园网访问文献数据库，上谷歌学术 写在前面对于研究生来说谷歌和谷歌学术真的必不可少，但是一般在家中基本连不上这两个网站。博主马上也要放假了，在家说不定还能瞄几眼文献，所以就用现有的设备搞一个小服务器。 准备 树莓派一套 shadowsocks VPS或者一个云主机比如(新浪云或者腾讯云,阿里云等) 自己使用的电脑mac或者windows 树莓派的配置树莓派的链接我有一块显示屏，省掉了很多麻烦事情。当然没有显示屏可以利用ssh进行链接访问使用ssh命令树莓派默认的用户为raspberrrypi 我们启用root权限12ssh username@ipofyourraspberrysu 安装shadowsocks1sudo pip install shadowsocks 创建shadowsocks服务器如果你之前没有接触过ss这里有介绍首先配置文件首先创建文件：sudo mkdir /etc/shadowsocks/config.json修改配置文件: sudo vi /etc/shadowsocks/config.json 添加代码如下123456789101112131415161718192021&#123;"server": "0.0.0.0","server_port": 443,"local_address": "127.0.0.1","local_port": 1080,"password": "celerysoft.github.io","timeout": 300,"method": "aes-256-cfb","fast_open": false,"workers": 1&#125; 参数解释： 参数 说明 server 服务端监听地址(IPv4或IPv6) server_port 服务端端口，一般为443 local_address 本地监听地址，缺省为127.0.0.1 local_port 本地监听端口，一般为1080 password 用以加密的密匙 timeout 超时时间（秒） method 加密方法，默认为aes-256-cfb，更多请查阅Encryption fast_open 是否启用TCP-Fast-Open，true或者false workers worker数量，如果不理解含义请不要改（这个只在Unix和Linux下有用） 启动服务器1sudo ssserver -c /etc/shadowsocks/config.json -d start 关闭服务器1sudo ssserver -c /etc/shadowsocks/config.json -d stop 重启服务器1sudo ssserver -c /etc/shadowsocks/config.json -d restart 添加到开机启动项12vi /etc/rc.local ## 在exit 0前面添加sudo ssserver -c /etc/shadowsocks/config.json -d start## 可实现开机运行我们 踩过的坑如果出错可能是因为cleanup需要被更换成reset我们看一下shadowsocks安装位置1234567891011121314$ sudo pip show --files shadowsocksName: shadowsocksVersion: 2.8.2Summary: A fast tunnel proxy that help you get through firewallsHome-page: https://github.com/shadowsocks/shadowsocksAuthor: clowwindyAuthor-email: clowwindy42@gmail.comLicense: http://www.apache.org/licenses/LICENSE-2.0Location: /usr/local/lib/python2.7/dist-packagesRequires: Files: ../../../bin/sslocal ..... 可以看到shandowsock安装的具体位置，cd到其中将openssl.py文件中的clean_up全部替换为reset1sudo vi /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py 然后再启动就OK了 连接云主机这一部分放在云主机配置完后再讲具体命令是：1sudo ssh -fNC -R 0.0.0.0:1080:127.0.0.1:443 ubuntu@biueo.com 云主机的配置&emsp;&emsp;树莓派配置好了，云主机的配置就简单了，他的作用就是能够让非局域网的网友以此为跳板访问局域网，就是所谓的内网穿透，我们的云主机负责接受访问请求，然后转发给树莓派，树莓派请求校园网主机，然后依次返回结果。 云主机配置端口映射&emsp;&emsp;首先你需要确保，这台远程机器允许远程转发，需要做的是登录它，我同样适用使用ssh进行登录，我的主机是ubuntu系统，并且已经和域名绑定了，这一点非常方便，直接输入域名即可，ssh username@biueo.com ,然后修改/etc/ssh/sshd_config文件，在 文件末尾添加GatewayPorts yes，然后用命令sudo service ssh reload重启ssh服务器。1234ssh username@biueo.com(这里是你的主机ip)sudo vi /etc/ssh/sshd_config#添加GatewayPorts yessudo service ssh reload &emsp;确保你的特定端口没有被使用，我们适用1080端口用命令查看端口占用情况：12sudo lsof -i:1080 sudo kill PID（进程PID号）##杀死占用端口的进程 树莓派连接云主机使树莓派通过服务器端口，listen云主机转发的请求，然后传递给校园网服务器1ssh -fNC -R 0.0.0.0:1080:yourhostname:443 your-user-name@your-server-ip # yourhostname可以用127.0.0.1代替 这时候应该需要输入云主机的登录密码，输入即可。 客户端使用shadowsocks上面介绍的这种方式需要通过shadowsocks登录，需要各个平台下载不同的shadowsocks，地址参考这里然后输入你的云主机ip地址和端口1080密码是你在树莓派上设置的password,然后即可使用。因为我的校园网可以通过ipv6访问google,这样通过代理也能够访问google了。 选择代理方式这样需要我们在树莓派上直接开一个shadowsocks客户端和一个服务器。客户端负责连接服务器，云主机不做改变，这样我们可以只需要在特定的平台改变代理就可了，不需要安装shadowsocks.12sudo ssserver -p 443 -k password -m aes-256-cfb #打开服务器 password改成自己的密码sslocal -s 127.0.0.1 -p 443 -b 127.0.0.1 -l 1080 -k password #创建客户端 然后在自己的pc或者手机上添加代理，具体的可以参考这里 Enjoy it! 附上一个小笔记：树莓派重启samba使用：sudo /etc/init.d/samba restart树莓派ip查看hostname I树莓派hosts位置/etc/hosts树莓派查看端口netstat -anp树莓派启动ipv6vi /etc/modprobe.d/ipv6.conf]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>SSH</tag>
        <tag>内网穿透</tag>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典笔记]]></title>
    <url>%2F2018%2F01%2F27%2FPython%E5%AD%97%E5%85%B8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python核心编程字典学习笔记 映射类型的内建方法 方法名字 操作 dict.clear() 删除字典中所有元素 dict clear() 返回字典的一个副本 dict.fromkeys(seq,valNone) 创建并且返回一个新字典，以seq中的元素作为该字典的键，val做该字典中所有键对应的初始值如果没有此值返回None dict.get(key,default=None) 对字典的键Key进行取值，没有返回default的值 dict.has_key(key) 判断字典中是否存在键key，如果存在返回True,否则False. dict.items() 返回一个包含字典的键、值对元组的列表 dict.keys() 返回一个包含字典中键的列表 dict.iter() 方法iteritems(),iterkeys(),itervalues()与它们对应的非迭代方法一样，不同的是它们返回一个迭代子，而不是一个列表 dict.pop(key[,default=None]) 和get()方法类似，删除并且返回dict[key];如果不存在，且没有给出default则出现异常 dict.setdefault(key,default=None) 和set()方法类似，如果不存在key键，由dict[key]=default为他赋值 dict.update(dict2) 将字典dict2的键-值对添加到dict中 dict.values() 返回一个字典中所有值得列表]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记-字符串、列表]]></title>
    <url>%2F2018%2F01%2F27%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Python核心笔记之字符串、列表和元组 序列序列包括字符串、列表和元组等他们的成员有序排列，并且通过下标偏移量访问到它的一个或者几个成员。 序列类型操作符 序列操作符 作用 seq[index] 获得下标index的元素 seq[ind1:ind2] 获得下标从ind1到ind2之间的元素(包含ind1,不包含ind2) seq*expr 序列重复expr次 seq1+seq2 链接seq1和seq2 obj in seq 判断obj是否包含在seq中 obj not in seq 判断obj是否不包含在seq中 连接操作符‘+’不是最有效的，对于字符串来说，一般调用join()方法吧所有内容连接在一起，对于列表来说可以使用列表类型的extend()方法将两个或者多个列表对象合并。 对于切片操作有几种常见的用法： 切片操作1234567s='abcdefgh's[::-1] ## 翻转操作s[::2] ## 隔一个取一个操作&gt;&gt;&gt; s[:-1]'abcdefg'&gt;&gt;&gt; s[:None] # 能够取到最后一个'abcdefgh' 内建函数序列类型转换的工厂函数 函数 含义 list(iter) 把可迭代对象转化为列表 str(obj) 把obj对象转化成字符串 unicoce(obj) 把对象转化成Unicode字符串，使用默认编码 basestring() 抽象工厂函数，其作用仅仅为str和Unicode函数提供父类所以不能被实例化，也不能被调用 tuple(iter) 把一个可迭代对下转化成一个元组元素 序列类型可用的内建函数 函数名 功能 enumerate(iter) 接受一个可迭代对象作为参数，返回一个enumerate对象（同时也是一个迭代器）该对象生成由iter每一个元素的index值和item值组成的元组。 len(seq) 获得seq的长度 max(iter,key=None) or min(arg0,arg1…,key=None) 返回iter或arg0,arg1…中的最大值/最小值，如果指定key,这个key必须是一个可以传给sort()方法的用于比较的回调函数 reversed(seq) 接受一个序列作为参数，返回一个以逆序访问的迭代器 sorted(iter,fun=None,key=None,reverse=False) 接受一个可迭代对像作为参数，返回一个有序的列表，可选参数func,key和reverse的含义跟list.sort()内建函数的参数含义一样 sum(seq,init=0) 返回seq和可选参数init的总和，等同于reduce(operator.add,seq,init) zip([it0,it1,…itN]) 返回一个列表，其第一个元素是it0,it1…这些元素的第一个元素组成的一个元组，第二个…依次类推 字符串字符串的比较按照ASCII值的大小来比较的。 只用于字符串的操作符 格式化操作符（%） 格式化字符 转换方式 %c 转换成字符(ASCII码值或者长度为一的字符串) %r 优先用repr()函数进行字符串转换 %s 优先使用str()函数进行字符串转换 %d %i 转换成有符号十进制数 %u 转换成无符号十进制数 %o 转换成无符号八进制数 %x/%X 转化成无符号十六进制数 %f/%F 转化成浮点型，小数部分自然截断可以采用%0.2f/%0.nf保留n位小数位 %e/%E 转成科学计数法 %g/%G %s和%f%E和%F的简写 %% 输出% 格式化字符辅助指令 符号 作用 * 定义宽度和小数点精度 - 用做左对齐 + 在整数前面显示空格 在正数前面显示空格 # 在八进制前面显示零，在十六进制前面显示0x或者0X 0 显示数字前面填充‘0’而不是空格 % ‘%%’输出一个单一的% （var） 映射变量（字典参数） m.n m是显示的最小宽度，n是小数点后的位数 12345678910111213&gt;&gt;&gt;'%x' % 108'6c'&gt;&gt;&gt;'%#x' %108'0x6c'&gt;&gt;&gt;'%#X' %108'0X6C'&gt;&gt;&gt;'%.2f' %123.456'123.45'&gt;&gt;&gt;'%+d' %4'+4'&gt;&gt;&gt;'%+d' %-4'-4'&gt;&gt;&gt; 'host %s Port :%d' %('mars',80) 原始字符串操作符(r/R)Unicode字符串操作符(u/U) 1234&gt;&gt;&gt;r'\n''\\n'&gt;&gt;&gt;u'abc'U+0061 U+0062 U+0063 字符串类型函数： input()、str()、unicode()、chr()、unichr()、ord() 字符串常用内建函数 内建函数1 解释 string.capitalize() 把字符串的第一个字符大写 string.center(width) 返回一个原字符串居中,并使用空格填充至长度 width 的新串 string.count(str, beg=0, end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指返回指定范围内 str 出现的次数 string.decode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式解码 string，如果出错默认报ValueError 的异常，除非 errors 指定的是’ignore’或’replace’ string.encode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式编码 string，如果出错默认报ValueError的异常， 除非errors指定的是’ignore’或者’repl string.endswith(obj, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果 beg 或者 end 指定则检定的范围内是否以 obj 结束， 如果是， 返回True,否则返回Fa string.expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格， 默认格数 tabsize 是 8. string.find(str, beg=0, end=len(string)) 检测 str 是否包含在 string 中，如果 beg 和 end 指定范则检查是否包含在指定范围内，如果是返回开始的索引值，返回-1 string.index(str, beg=0, end=len(string)) 跟find()方法一样， 只不过如果str不在string中会报一个异 string.isalnum() a, b, c R如果string至少有一个字符并且所有字符都是字母或数字回 True,否则返回 False string.isalpha() a, b, c 如果string至少有一个字符并且所有字符都是字母则返回T否则返回 False string.isdecimal() b, c, d 如果 string 只包含十进制数字则返回 True 否则返回 False. string.isdigit() b, c 如果 string 只包含数字则返回 True 否则返回 False. string.islower() b, c 如果 string 中包含至少一个区分大小写的字符，并且所有这些(大小写的)字符都是小写，则返回 True，否则返回 False string.isnumeric() b, c, d 如果 string 中只包含数字字符，则返回 True，否则返回 False string.isspace() b, c 如果 string 中只包含空格，则返回 True，否则返回 False. string.istitle() b, c 如果 string 是标题化的(见 title())则返回 True，否则返回 False string.isupper() b, c 如果 string 中包含至少一个区分大小写的字符， 并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False string.join(seq) Merges (concatenates)以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 string.ljust(width) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 string.lower() 转换 string 中所有大写字符为小写. string.lstrip() 截掉 string 左边的空格 string.partition(str) e 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string. string.replace(str1, str2, num=string.count(str1)) 把 string 中的 str1 替换成 str2,如果 num 指定， 则替换不超过 num 次. string.rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. string.rindex( str, beg=0,end=len(string)) 类似于 index()， 不过是从右边开始. string.rjust(width) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 string.rpartition(str) e 类似于 partition()函数,不过是从右边开始查找. string.rstrip() 删除 string 字符串末尾的空格. string.split(str=””, num=string.count(str)) 以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串 string.splitlines(num=string.count(‘\n’)) b, c按照行分隔， 返回一个包含各行作为元素的列表， 如果 num 指定则仅切片 num 个行. string.startswith(obj, beg=0,end=len(string)) b, e检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查. string.strip([obj]) 在 string 上执行 lstrip()和 rstrip() string.swapcase() 翻转 string 中的大小写 string.title() b, c 返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) string.translate(str, del=””) 根据str给出的表(包含256个字符)转换string的字符,要过滤掉的字符放到 del 参数中 string.upper() 转换 string 中的小写字母为大写 string.zfill(width) 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 列表列表类型内建函数 列表函数 作用 list.append(obj) 向列表中添加一个对象obj list.count(obj) 返回一个对象obj在列表中出现的次数 list.expend(seq) 把序列seq的内容添加到列表中 list.index(obj,i=0,j=len(list)) 返回list[k]==obj的k值，并且k的范围在i&lt;=k&lt;j;否则引发ValueError异常 list.insert(index,obj) 在索引量为index的位置插入obj list.pop(index=-1) 删除并返回指定位置的对象，默认为最后一个对象 list.remove(obj) 从列表中删除对象obj list.reverse() 原地反转列表 list.sort(func=None,key=None,reverse=False) 以指定的方式排序列表中的成员，如果func和key参数指定，则按照指定的方式比较各元素，如果reverse为True,则列表以反序排列 列表的特殊特性列表可以构建其他数据结构 堆栈 堆栈是一个后进先出的数据结构，push添加一元素，删除是pop 使用列表的append()和pop()方法实现 堆栈1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env pythonstack = []def pushit(): stack.append(input('Enter New String: ').strip())def popit(): if len(stack)==0: print('cannot pop from an empty stack') else: print('Remove [',stack.pop(),',]')def viewstack(): print(stack)CMDs=&#123;'u':pushit,'o':popit,'v':viewstack&#125;def showmenu(): pr=''' P(U)sh p(O)p (V)iew (Q)uit Enter choice: ''' while True: while True: try: choice=input(pr).strip()[0].lower() except(EOFError,KeyboardInterrupt,IndexError): choice='q' print('\n You picked:[%s]' %choice) if choice not in 'uovq': print('Invalid option ,try agagin') else: break if choice=='q': break CMDs[choice]()if __name__()=='__main__': showmenu() 列表做队列 队列 队列是一种先进先出的数据类型 构造是需要将构造堆栈时的pop函数进行一下修改，修改成stack.pop(0) 元组元组是一种不可变类型，so他可以干一些列表不能干的事情，比如做一个字典的Key 元组可以进行索引，切片，但是要修改元组则需要新建一个元组。 本身不可变，但是包含的可变对象则可变 比如([1,2],3,5)列表则可以变化 但是元组也不是完全不可变：连接，重复都可以改变元组的值。1234t=(1,2)t=t+(3,4)&gt;&gt;&gt; t(1,2,3,4) 内建的tuple()函数和list()函数可以实现元组和列表之间的转换 参考链接1.http://blog.csdn.net/heverst/article/details/76117079 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python核心编程学习笔记]]></title>
    <url>%2F2018%2F01%2F26%2Fpython%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python核心编程第十三章类的笔记 主要是这章的课后比较经典的习题 第一题： 函数和方法比较，函数和方法之间的区别是什么？ 答： 函数需要手动传入self,方法不需要 如果一个函数用类名去掉用，如果是一个方法则需要一个对象去调用。 第二题： 对类的定制，要求：编写一个dollarize()函数，它以一个浮点型值作为输入，返回一个字符串形式的金额数比如说：dollarize(1234.678) =&gt;’$1,234.678’ dollarize()返回的金额数里应该允许存在逗号，如果有符号在应该出现在美元货币符号的左边，完成工作后可以构造一个类用MoneyFmt表示。MoneyFmt类里只有一个数据值，和五个方法构造器__init__初始化，update把数据值更新为一个新值。 answerto112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class MoneyFmt(object): ''' Format the money to dollar''' def __init__(self,mount): self.m=float('%.2f' %mount) def dollarize(self): fnum='%.2f'%self.m ffom,*bfom=str(fnum).split('.') ffom=''.join(self.insertcom(ffom,3)) return '%s.' %ffom+bfom[0] def insertcom(self,seq,num): if seq[0]!='-': listseq=list(reversed(list(seq))) listwithcom=[] for i in range(len(listseq)): listwithcom.append(listseq[i]) if (i+1)%num==0 and i+1!=len(seq): listwithcom.append(',') listwithcom.append('$') return reversed(listwithcom) else: listseq=list(reversed(list(seq[1:]))) listwithcom=[] for i in range(len(listseq)): listwithcom.append(listseq[i]) if (i+1)%num==0 and i+1!=len(listseq): listwithcom.append(',') listwithcom.append('$') listwithcom.append(seq[0]) return reversed(listwithcom) def update(self,val): if val: try: self.m=float('%.2f' %val) except TypeError as e: print (e) def __str__(self): return self.dollarize() __repr__=__str__ def __bool__(self): if self.m&gt;=1: return True else: return False 关于__nonzero__()函数的一个解释 If a class defines it, this special method is called whenever an instance is converted to a Boolean value, either implicitly (for example, when it is the test in an “if” statement) or explicitly via the built-in bool() function. python3 中使用__bool__()代替他]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题笔记1]]></title>
    <url>%2F2018%2F01%2F25%2FLeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[使用python刷leetcode笔记一 第一题 - Two Sum链接：https://leetcode.com/problems/two-sum/description/ 题目分析题目 Given an array of integers, retrun indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 翻译：给定一个整数数组序列，和一个和的目标值，计算这个序列中是否存在两个数字相加等于目标值，存在返回两个元素的索引，序列中任何一个元素只能使用一次。 Example: Givern nums =[2,7,11,15], target=9. Because nums[0]+nums[1]=2+7=9 return [0,1] 结果代码先上自己的代码然后比较自己的代码存在的不足之处， 自己的代码12345678910111213141516class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dic=&#123;&#125; sub=[ target-i for i in nums] for i in range(len(nums)): if nums[i] in [sub[t] for t in range(len(nums)) if t!=i]: for t in range(len(sub)): if nums[i]==sub[t]: j=t return[i,j] return False 虽然能解决问题但是代码过于臃肿，执行效率也不是很高再看网友代码： 网友代码123456789101112131415class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums)&lt;=1: return False budict=&#123;&#125; for i in range(len(nums)): if nums[i] in budict: return [budict[nums[i]],i] else: budict[target-nums[i]]=i 比较而言，网友代码应该更合适，下面对此代码进行分析理解。 本题笔记 代码中使用了字典，关于字典的键值关系可以解决找到索引的功能 代码中采用for循环，对每次的数值进行查询是否满足之前值和目标值的差值，如果满足则返回此值的序号，以及之前差值的序号，差值的索引就是通过字典功能实现的。 第二题 - Add Two Numbers链接：https://leetcode.com/problems/add-two-numbers/description/ 题目分析题目 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself 翻译：给定两个非负整数数链表，链表每个值代表数字个十百千……位上的值。 Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. 结果代码本题考察到python中的链表 代码1234567891011121314151617181920#Definition for singly-linked list. class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): carry=0 # 进位数值 result=n=ListNode(0) def addnums(self,l1,l2): while l1 or l2 or carry: if l1: l1c=l1.val l1=l1.next if l2: l2c=l2.val l2=l2.next carry,val=divmod(l1c+l2c+carry,10) n.next=ListNode(val) n=n.next return result.next 本题笔记 这道题主要考察链表操作 链表操作之所以出现result=n=ListNode(0)，因为n在循环叠加中n=n.next会有如此变化，所以直接定义一个等同的值result来实现结果输出。 第三题 - Longest Substring Without Repeating Characters链接:https://leetcode.com/problems/longest-substring-without-repeating-characters/description/ 题目分析Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 就是寻找一个字符串中不重复出现的最大长度 结果代码本人代码1234567891011121314151617181920class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ if len(s)&lt;1: return 0 sub=s[0] for i in range(len(s)-1): j=1 while (s[i+j] not in s[i:i+j]): if (i+j+1&lt;=len(s)-1) : j+=1 else: j+=1 break if len(s[i:i+j])&gt;len(sub): sub=s[i:i+j] return len(sub) 👆是本人代码，虽然记过能够算对，但是最后提交时，一个非常长的字符串运算超出了时间。思想是：从左往右依次查看字符，如果和之前的字符不重复，则继续累加，如果重复则截断，选取当前长度和前面最大截断的长度中最长的哪一个。直到字符串结束为止。 他人代码12345678910111213class Solution(object): def lengthOfLongestSubstring(self, s): dic, res, start, = &#123;&#125;, 0, 0 for i, ch in enumerate(s): if ch in dic: # update the res res = max(res, i-start) # here should be careful, like "abba" start = max(start, dic[ch]+1) dic[ch] = i # return should consider the last # non-repeated substring return max(res, len(s)-start) 这个代码的思想是，出现重复字符后，计算和前一个相同字符之间的距离，保留最长的哪一个即可。start逐渐往右移动，语句start=max(start,dic[ch]+1)就是为了防止’abba’这种情况返回左边👈 本题笔记 巩固一下enumerate()函数 编程中注意时间问题 每个人的思想不同，最后的程序就不同，所以训练不仅要训练语言的使用能力，更要训练逻辑编程能力]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>刷题笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双折射基础知识]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%8F%8C%E6%8A%98%E5%B0%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[通过两个PPT学习一下双折射的基础知识 第一篇讲双折射基础知识 第二篇PDF主要讲双折射晶体的原理]]></content>
      <categories>
        <category>老本行</category>
      </categories>
      <tags>
        <tag>Laser</tag>
        <tag>光学基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干了这碗汤，让我们上路]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%B9%B2%E4%BA%86%E8%BF%99%E7%A2%97%E6%B1%A4%EF%BC%8C%E4%B8%8A%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[40条人生经验，可以认真看看 除了自身的病患或亲友离去的痛苦是真实的，其他的痛苦都是你自己的价值观带给你的。 沉不下心看书，浮躁和焦虑，都是因为年纪渐长，不信正道而太重功利导致的。 真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。 一个人明白自己能做什么远比自己想做什么重要得多，前者需要给自己设定一个现实的疆域，是一种尽力而为的勤奋，后者是任性催生的热情，往往来自于对世界的无知和自负。一个人，一定要清楚地认识自己。 便宜莫贪，天下没有免费的午餐。想得到任何东西之前都要先问问自己，是否付得起相应的代价。 在早上把你叫醒的，不应该是闹钟，不应该是闹钟，而应该是昨天早睡。 太用力的人，跑不远，别把人生的马拉松当成百米冲刺；太用力的爱不仅让自己累，也让身边的人累，最终难以圆满。 “事非宜，勿轻诺。苟轻诺，进退错。”没有把握的事情不要轻易答应，如果答应了做不好，进退都是错误的，很容易让自己陷入里外不是人的尴尬局面。 天下古今之庸人，皆以一惰字致败；天下古今之人才，皆以一傲字致败。 你不必去找人脉，唯一需要操心的是要把自己的本事练好。 永远不要与人去辩论，你也很难把别人辩服，因为立场不同，因为没有对错，只有规则，只有利益。圈子不同，不必强融。 一定要去掌控自己的生活，而不要让生活带着你走。 蔡康永曾说，你15岁的时候觉得游泳难，放弃游泳，到18岁遇见一个你喜欢的人约你去游泳，你只好说：“我不会耶”。你18岁觉得英语难，放弃英语，你28岁遇到了一份非常好也很适合你但是要求会英语的工作，你只好说“我不会耶”。出来混总是要还的，前期偷懒，后期肯定要花数倍的精力来弥补，更遗憾的是，不一定补得上。人生最可怕的事，是一边后悔一边生活。 婚姻里的指责和抱怨不是因为“我爱你”，而是因为“我情绪管理不好”。指责不是爱，而是婚姻的杀手。 父母的话不全是对的，父母的爱不全是无私的。 成熟不等于世故，知世故而不世故，才是最善良的成熟。 你其实并没有想象中那么依赖父母，但父母依赖你的程度远远超过于你的想象。 尽量不给别人添麻烦，别人最好也别麻烦我。这句话不是冷漠，是成熟。 分开的时候一定要用力告别，因为说再见，也许真的是再也不见。 所有你此刻觉得不可承受，不可跨越的苦难，一旦经受住了，回头看，不过是浮云一片。 当你的学业、工作、生活不顺利的时候，切记不要把爱情当成你的救命稻草。 我们总是喜欢拿顺其自然来敷衍人生道路上的荆棘坎坷，却很少承认，真正的顺其自然，其实是竭尽所能之后的不强求，而非两手一摊的不作为。 耳不闻人之非，目不视人之短，口不言人之过。 看破不说破，知人不评人，知理不争论。刻薄嘴欠和幽默是两回事，口无遮拦和坦率是两回事，没有教养和随性是两回事。 在事情没有成功之前，不要在人前谈及任何有关的计划和想法。世界不会在意你的自尊，只是你的成就。在你没有成就之前，切勿强调自尊。 世界不是公平的，人与人之间在某些方面就是天生存在不可逾越的差距。 有事情是要说出来的，不要等着对方去领悟，因为对方不是你，不知道你想要什么，等到最后只能是伤心和失望，尤其是感情。 社会真的很残酷，你的能力和价值越低，被淘汰的就越快。 最简单却也是最难的事：少熬夜，多看书，多喝热水，多运动，用心爱一个人。 婚姻不是劫富济贫，女人一定要经济独立。男人对你再好，自己有那才是真的有。 无论是男人还是女人，都要学着去做家务。做家务不是谁伺候“谁”的问题，而是培养一个人独立生活的技能。 不管平时关系如何，涉及金钱问题，务必要划分清楚。 经济能力跟在家里掌握的话语权是成正比的 照顾好自己的身体，很有必要。一个很差的身体带给你的局限不可能靠意志力突破。 社会没有那么复杂，复杂的是人心。 不管外面的世界究竟是什么样，能影响到你的，其实就身边的几个人。没有能力改变这世界，至少可以选择与谁同行。 到那种始终不在一个频道死活聊不到一个点上的人就别强求了，也千万不要试图努力，越努力越绝望。在婚姻里，精神上的门当户对比物质更重要。三观不同，真的不能结婚。 奋斗就是每一天很难，可一年一年却越来越容易；不奋斗就是每天都很容易，可一天一天越来越难。 无论是工作，生活，还是婚姻，不要去攀比嫉妒，没有对比就没有伤害。一生很长，疲惫、烦躁、失望都会有，看清真相后，请依然热爱生活。 最后一个道理其实是悖论，就是无论你听过再多的道理，当你没有经历过一些事情或者心智没有达到这个境界的时候，你是不会理解这个道理的。但愿，你的每一步都走得踏实，有力，不后悔。还有，也不要盲目相信上面的话，实践出真知。 *作者：楠瓜，来源：视觉志]]></content>
      <categories>
        <category>文字</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的os模块]]></title>
    <url>%2F2018%2F01%2F21%2Fpythonz%E4%B8%AD%E7%9A%84os%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Python中os模块简介 os.path.join()如果将单个文件和路径上的文件夹名称的字符串传递给它，os.path.join()就会返回一个文件路径的字符串，包含正确的路径分隔符。 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.path.join('usr', 'bin', 'spam')'usr\\bin\\spam 我在Windows上运行这些交互式环境的例子，所以，os.path .join(‘usr’, ‘bin’, ‘spam’)返回’usr\bin\spam’（请注意，倒斜杠有两个，因为每个倒斜杠需要由另一个倒斜杠字符来转义）。如果我在OS X或Linux上调用这个函数，该字符串就会是’usr/bin/spam’。 如果需要创建文件名称的字符串，os.path.join()函数就很有用。这些字符串将传递给几个文件相关的函数，本章将进行介绍。例如，下面的例子将一个文件名列表中的名称，添加到文件夹名称的末尾。 123456&gt;&gt;&gt; myFiles = ['accounts.txt', 'details.csv', 'invite.docx']&gt;&gt;&gt; for filename in myFiles: print(os.path.join('C:\\Users\\asweigart', filename))C:\Users\asweigart\accounts.txtC:\Users\asweigart\details.csvC:\Users\asweigart\invite.docx os.getcwd()、os.chdir()利用os.getcwd()函数，可以取得当前工作路径的字符串，并可以利用os.chdir()改变它。在交互式环境中输入以下代码： 123456&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()'C:\\Python34'&gt;&gt;&gt; os.chdir('C:\\Windows\\System32')&gt;&gt;&gt; os.getcwd()'C:\\Windows\\System32 如果要更改的当前工作目录不存在，Python就会显示一个错误 os.makedirs()程序可以用os.makedirs()函数创建新文件夹（目录）。在交互式环境中输入以下代码： 12import osos.makedirs('C:\\delicious\\walnut\\waffles') os.path.abspath()、os.path.isabs(path)、os.path.relpath(path,start)调用os.path.abspath(path)将返回参数的绝对路径的字符串。这是将相对路径转换为绝对路径的简便方法。 调用os.path.isabs(path)，如果参数是一个绝对路径，就返回True，如果参数是一个相对路径，就返回False。 调用os.path.relpath(path, start)将返回从start路径到path的相对路径的字符串。如果没有提供start，就使用当前工作目录作为开始路径。 1234567891011121314os.path.abspath('.')'C:\\python34'os.path.abspah('.scripts')'C:\\python34\\scripts'os.path.isabs('.')Falseos.path.isabs(os.path.abspath('.'))Trueos.path.relpath('C:\\windows','C:\\')'windows'os.path.relpath('C:\\windows','C:\\spam\\eggs')'..\\..\\windows'os.getcwd'c:\\python34' os.path.basename(path)、os.path.dirname(path)、os.path.split()、os.path.sep调用os.path.basename(path)将返回一个字符串，它包含path 参数中最后一个斜杠之后的所有内容。一个路径的目录名称和基本名称如图8-4所示。 12345&gt;&gt;&gt; path = 'C:\\Windows\\System32\\calc.exe'&gt;&gt;&gt; os.path.basename(path)'calc.exe'&gt;&gt;&gt; os.path.dirname(path)'C:\\Windows\\System32 如果同时需要一个路径的目录名称和基本名称，就可以调用os.path.split()，获得这两个字符串的元组，像这样： 123&gt;&gt;&gt; calcFilePath = 'C:\\Windows\\System32\\calc.exe'&gt;&gt;&gt; os.path.split(calcFilePath)('C:\\Windows\\System32', 'calc.exe') 同时也请注意，os.path.split()不会接受一个文件路径并返回每个文件夹的字符串的列表。如果需要这样，请使用split()字符串方法，并根据os.path.sep中的字符串进行分割。回忆一下，根据程序运行的计算机，os.path.sep变量设置为正确的文件夹分割斜杠。 12&gt;&gt;&gt; calcFilePath.split(os.path.sep)['C:', 'Windows', 'System32', 'calc.exe'] 在OS X和Linux系统上，返回的列表头上有一个空字符串： 12&gt;&gt;&gt; '/usr/bin'.split(os.path.sep)['', 'usr', 'bin'] os.path.getsize(path)、os.listdir(path)os.path模块提供了一些函数，用于查看文件的字节数以及给定文件夹中的文件和子文件夹。调用os.path.getsize(path)将返回path参数中文件的字节数。调用os.listdir(path)将返回文件名字符串的列表，包含path参数中的每个文件（请注意，这个函数在os模块中，而不是os.path）。 123456&gt;&gt;&gt; os.path.getsize('C:\\Windows\\System32\\calc.exe')776192&gt;&gt;&gt; os.listdir('C:\\Windows\\System32')['0409', '12520437.cpx', '12520850.cpx', '5U877.ax', 'aaclient.dll',--_snip_--'xwtpdui.dll', 'xwtpw32.dll', 'zh-CN', 'zh-HK', 'zh-TW', 'zipfldr.dll'] 如果想知道这个目录下所有文件的总字节数，就可以同时使用os.path.getsize()和os.listdir()。 12345totalsize=0for filename in os.listdir('c:\\windows\\systems32'): totalsize=totalsize+os.path.getsize(os.path.join('c:\\windows\\systems32',filename))print (totalsize)11178444444 os.path.exists(path)、os.path.isfile(path)、os.path.isdir(path)检查路径的有效性，os.path模块提供了一些函数，用于检验给定的路径是否存在，以及他是文件还是文件夹？ 123456789101112&gt;&gt;&gt; os.path.exists('C:\\Windows')True&gt;&gt;&gt; os.path.exists('C:\\some_made_up_folder')False&gt;&gt;&gt; os.path.isdir('C:\\Windows\\System32')True&gt;&gt;&gt; os.path.isfile('C:\\Windows\\System32')False&gt;&gt;&gt; os.path.isdir('C:\\Windows\\System32\\calc.exe')False&gt;&gt;&gt; os.path.isfile('C:\\Windows\\System32\\calc.exe')True 利用os.path.exists()函数，可以确定DVD或闪存盘当前是否连在计算机上。例如，如果在Windows计算机上，我想用卷名D:\检查一个闪存盘，可以这样做： 12&gt;&gt;&gt; os.path.exists('D:\\')False 这就是没有插上闪存盘 open()、read()、readlines()、write()用open()函数打开一个文件，就要向它传递一个字符串路径，表明希望打开的文件。这既可以是绝对路径，也可以是相对路径。open()函数返回一个File对象。调用open()将返回一个File对象。File对象代表计算机中的一个文件，它只是Python中另一种类型的值，就像你已熟悉的列表和字典。在前面的例子中，你将File对象保存在helloFile变量中。现在，当你需要读取或写入该文件，就可以调用helloFile变量中的File对象的方法用File对象的read()方法可以让我们继续使用保存在其中的对象 123&gt;&gt;&gt; helloContent = helloFile.read()&gt;&gt;&gt; helloContent'Hello world! 使用readlines()方法，从该文件取得一个字符串的列表。列表中的每个字符串就是文本中的每一行。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>os模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django之Windows系统网站部署-Apache+mod_wsgi+VC14]]></title>
    <url>%2F2018%2F01%2F21%2FDjango%E4%B9%8BWindows%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2-Apache-mod-wsgi-VC14%2F</url>
    <content type="text"><![CDATA[Windows下将Django通过Apache部署 安装Apache环境进入Apache的官方网站：http://httpd.apache.org进入Apache2.4 的下载页面：https://www.apachehaus.com/cgi-bin/download.plx 根据你的系统下载相应的版本，但是要知道版本需要VC编译支持，下载的时候看清楚需要安装的VC版本，本例程，选用的是：Apache 2.4.27 x64 VC14版本。 点击右方小图标进项下载。下载完成后将其中的Apache24进行解压，解压位置不要使用中文名，本例子放在了C:\Apache24中，cd到当前文件夹下的bin中运行命令如下： 12cd C:\Apache24\binhttpd -k install 结果会出现 1ServerRoot must be a valid directory 的错误，这是因为conf文件中httpd.conf的配置路径有问题： 12345Define SRVROOT &quot;/Apache24&quot; #这是默认的 ServerRoot &quot;$&#123;SRVROOT&#125;&quot;# 需要修改为：Define SRVROOT &quot;C:\Apache24&quot; #修改到此解压目录下 ServerRoot &quot;$&#123;SRVROOT&#125;&quot; 再次运行： 1234httpd -k installThe &quot;Apache2.4&quot; is successfuly installed .Testing httpd.confError: reported here must be corrected before the service can be started. 此时Apache安装完成，启动Apache 1234cd C:\Apache24\binnet start Apache2.4Apache2.4 服务正在启动...Apache2.4 服务启动成功。 在浏览器中打开http://localhost/即看到Apache官网代表启动成功 常见问题有： 端口设置有冲突，Apache默认使用的端口是80端口，如果不行可以尝试使用其他端口，只需要在httpd.conf中修改Listen选项 12345#Listen 12.34.56.78:80Listen 80 # 修改为其他选项Listen 8089 打开 http://localhost:8089即可netstat -aon|findstr &quot;49157&quot; # 用来查看端口的应用情况tasklist|findstr &quot;2720&quot;，#查看是哪个进程或者程序占用了2720端口 记下PID在进程里进行关闭即可taskkill /f /t /im Tencentdl.exe #结束Tencentdl.exe进程 安装VC14在https://www.microsoft.com/en-us/download/details.aspx?id=48145下载相应的VC，双击安装即可。如需卸载可用安装包进行卸载。 配置mod_wsgi文件mod_wsgi是windows平台，apache2下的插件，用于连接python，如果和Apache不匹配的话容易出现各种各样的问题。这一点很让人头疼。 根据此例子安装的Apache2.4（尽量使用此版本，2.2的话安装mod_wsgi极容易出现问题） 下载地址： 链接: https://pan.baidu.com/s/1eR7JijK 密码: ubpz 将文件中的so文件提取出来，还是根据不同系统选用不同的so文件，这里选择Apache24 V9 x64 py2.7版本的so文件mod_wsgi-py27-VC9.so。将此文件复制到C:\Apache\moduels\下 django项目中的wsgi.py文件在项目保持项目创建时候的样子，如果不存在在项目的setting.py同级文件夹中创建wsgi.py文件如下： 1234import osos.environ.setdefault("DJANGO_SETTINGS_MODULE", "myweb.settings")from django.core.wsgi import get_wsgi_applicationapplication = get_wsgi_application() 在setting.py文件中设置 1ALLOWED_HOSTS=["*"] 对httpd.conf文件修改1234567891011121314151617#添加mod_wsgi.so 模块LoadModule wsgi_module modules/mod_wsgi-py27-VC9.so#指定Django项目的wsgi.py配置文件路径 我的是：WSGIScriptAlias / C:\website\website\wsgi.py#指定项目路径WSGIPythonPath C:\website&lt;Directory C:\website\website&gt;&lt;Files wsgi.py&gt; Require all granted&lt;/Files&gt;&lt;/Directory&gt;#修改documentroot至Django项目路径DocumentRoot &quot;$&#123;SRVROOT&#125;/htdocs&quot;# 默认设置&lt;Directory &quot;$&#123;SRVROOT&#125;/htdocs&quot;&gt;# 默认设置#修改为：DocumentRoot &quot;C:\website&quot;&lt;Directory &quot;C:\website&quot;&gt; 关闭Django的Debug:在Django项目的setting.py文件中修改： 12#设置DebugDebug=False 这时候Django的静态文件无法使用需要Apache配置，还是修改httpd.conf 123456#添加下面语句Alias /static/ C:\website\static\&lt;Directory C:\website\static\&gt;Require all granted&lt;/Directory&gt; 重启Apache在C:\Apache24\bin\中运行apache-monitor.exe,点击restar即可在浏览器中输入http://localhost:8089/进行查看 Enjoy it]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网站部署</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql的常用命令-基础篇]]></title>
    <url>%2F2018%2F01%2F21%2FMysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Mysql常用的基础命令 参考博客示例博客：http://www.spiderpy.cn/blog 登录MySQLWindows系统下：运行cmd 输入：mysql -u 用户名 -p 接着输入用户密码即可进入数据库交互界面:mysql&gt; MacOS系统：在终端输入上面的命令，接着输入密码同样可以进入交互界面：mysql&gt; 命令行创建和删除数据库MacOS系统和Windows系统需要的命令一样： 12345mysql&gt;CREATE DATABASE `数据库名字`;mysql&gt; DROP DATABASE my_db1; Query OK, 0 rows affected (0.00 sec); 我们可以为数据库设定一些参数，比如编码方式，一般选择utf8，否则使用数据的时候容易出现乱码或错误。 设定编码参数的命令如下： 123CREATE DATABASE `数据库名字` DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;-- gbkUTF-8: CREATE DATABASE `数据库名字` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; -- utf8 数据库的导入导出导出整个数据库：1mysqldump -h[主机所在IP] -u[用户名] -p [要导出的数据库]&gt;[导出的路径//[文件名].sql] -- 本机的话可以不写主机或者写localhost也行，语句中没有中括号，中括号只是为了方便解释 上面是Windows系统的操作指令，路径注意是双斜杠，当然如果不写导出路径的话默认是运行命令的根目录，Windows系统一般是C:\Users\username，MacOS一般是/user/name 导入整个数据库：1.首先建立一个数据库，命令参考前面，然后使用命令： 1use 数据库名字 2.直接使用source [所在的路径//*.sql] 将SQL文件导入即可。比如： 12source d://gitdb.sqlQuery OK，0 rows affected &lt;0.00 sec&gt; 接下来会有一大串Query OK的信息。这样数据库就完美导入了。 导出一张表12mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中类的定制]]></title>
    <url>%2F2018%2F01%2F21%2Fpython%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9A%E5%88%B6%2F</url>
    <content type="text"><![CDATA[介绍怎么创建以个自定义的Python类 使用特殊方法定制类这些方法都是双下划线开始和结尾的。下表给出了全部的特殊方法及其描述。 使用定制类的特殊方法 特殊方法 描述 基本定制 C.__init__(self,[arg1,…]) 构造器(带一些可选参数) C.__new__(self[,arg1,…]) 构造器(带一些可选参数)通常用来设置不变数据类型的子类 C.__del__(self) 解构器 C.__str__(self) 可打印的字符输出；内建str()及print()语句 C.__repr__(self) 运行时的字符串输出；内建repr()和‘’操作符 C.__unicode__(self) Unicode字符串输出：内建Unicode() C.__call__(self,*args) 表示可调用的实例 C.__nonzero__(self) 为object定义False值；内建bool() C.__len__(self) “长度”；内建len() 对象值比较 C.__cmp__(self,obj) 比较对象；内建cmp() C.__lt__(self,obj) and C.__le__(self,obj) 小于/小于等于； C.__gt__(self,obj) and C.__ge__(self,obj) 大于/大于等于； C.__eq__(self,obj) and C.__ne__(self,obj) 等于/不等于； 属性 C.__getattr__(self,attr) 获取属性；内建getattr();仅当属性没有找到时调用 C.__setattr__(self,attr) 设置属性 C.__delattr__(self,attr) 删除属性 C.__getattrbute__(self,attr) 获取属性，总是被调用 C.__get__(self,attr) (描述符)获取属性 C.__set__(self,attr) (描述符)设置属性 C.__delete__(self,attr) (描述符)删除属性 定制类/模拟类型 C.__add__(self,obj) 加；+操作符 C.__sub__(self,obj) 减；-操作符 C.__mul__(self,obj) 乘；*操作符 C.__div__(self,obj) 除；/操作符 C.__truediv__(self,obj) True除；/操作符 C.__floordiv__(self,obj) 地板除；//操作符 C.__mod__(self,obj) 取模/取余；%操作符 C.__divmod__(self,obj) 除和取模；内建divmod（） C.__pow__(self,obj) 乘幂；内建pow();**操作符 数值类型：二进制操作符 C.__lshift__(self,obj) 左移位；&lt;&lt;操作符 C.__rshift__(self,obj) 右移位；&gt;&gt;操作符 C.__and__(self,obj) 按位与；&amp;操作符 C.__or__(self,obj) 按位或；&#124;操作符 C.__xor__(self,obj) 按位与或；^操作符 数值类型：一元操作符 C.__neg__(self) 一元负 C.__pos__(self) 一元正 C.__abs__(self) 绝对值；内建abs() C.__invert__(self) 按位求反；~操作符 数值类型：数值转换 C.__complex__(self,com) 转为complex(复数)；内建complex() C.__int__(self) 转为int；内建int() C.__long__(self) 转为long；内建long() C.__float__(self) 转为float；内建float() 数值类型：基本表示法 C.__oct__(self) 八进制表示；内建oct() C.__hex__(self) 十六进制表示；内建hex() 数值类型：数值压缩 C.__coerce__(self,num) 压缩成同样的数值类型；内建coerce() C.__index__(self) 在有必要时，压缩可选的数值类型为整型；比如用于切片索引 序列类型 C.__len__(self) 序列中项的数目 C.__getitem__(self,ind) 获取单个序列元素 C.__setitem__(self,ind,val) 设置单个序列元素 C.__delitem__(self,ind) 删除单个序列元素 C.__getslice__(self,ind1,ind2) 获取序列片段 C.__setslice__(self,ind1,ind2,val) 设置序列片段 C.__delslice__(self,ind1,ind2) 删除序列片段 C.__contain__(self,val) 测试序列成员，内建in关键字 C.__add__(self,obj) 串联；+操作符 C.__mul__(self,obj) 重复；*操作符 C.__iter__(self) 创建迭代类，内建iter() 映射类型 C.__len__(self) mapping中项的数目 C.__hash__(self) 散列hash的函数值 C.__getitem__(self,key) 得到给定建key的值 C.__setitem__(self,key) 设置给定建key的值 C.__delitem__(self,key) 删除给定建key的值 C.__missing__(self,key) 给定键如果不存在字典中，则提供一个默认值 简单定制 Time60类的定制构造一个整数的小时和分钟作为输入传给构造器 Time60类的构造1234class Time60(object): def __init___(self,hr,min): self.hr=hr self.min=min 显示__str__主要用于print函数的调用，而__repr__主要用于运行中，比如ipython中输出 显示123456789101112class Time60(object): def __init__(self,hr,minu): self.hr=hr self.min=minu def __str__(self): return '%d:%d'%(self.hr,self.minu) __repr__=__str__&gt;&gt;&gt; a=Time60(11,25)&gt;&gt;&gt; print(a)11:25&gt;&gt;&gt; a11:25 添加加法运算添加加法运算12345678910111213class Time60(object): def __init__(self,hr,minu): self.hr=hr self.minu=minu def __str__(self): return '%d:%d'%(self.hr,self.minu) __repr__=__str__ def __add__(self,other): return self.__class__(self.hr+other.hr,self.minu+other.minu)&gt;&gt;&gt; a=Time60(10,20)&gt;&gt;&gt; b=Time60(2,10)&gt;&gt;&gt; a+b12:30 添加原位加法运算，a+=1这中形式。__iadd__()原位加法运算1234567891011121314151617181920class Time60(object): def __init__(self,hr,minu): self.hr=hr self.minu=minu def __str__(self): return '%d:%d'%(self.hr,self.minu) __repr__=__str__ def __add__(self,other): return self.__class__(self.hr+other.hr,self.minu+other.minu) def __iadd__(self,other): self.hr=self.hr+other.hr self.minu=self.minu+other.minu return self&gt;&gt;&gt; a=Time60(10,30)&gt;&gt;&gt; id(a)4419258016&gt;&gt;&gt; b=Time60(2,20)&gt;&gt;&gt; a+=b&gt;&gt;&gt; id(a)4419258016 id()是内建函数为了证明我们修改了原对像而非创建了一个新的对象。 迭代器使用一个类中的iter()方法和next()方法来创建一个迭代器 __init__()执行赋值操作，__iter__()仅返回self,这就是一个对象声明为迭代器的方式，最后调用next来得到迭代器中连续的值。随机迭代器12345678from random import choice class Randseq(object): def __init__(self,seq): self.data=seq def __iter__(self): return self def next(self): return choice(self.data)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习笔记</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的类]]></title>
    <url>%2F2018%2F01%2F20%2Fpython%E4%B8%AD%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[介绍Python中的类的基础知识 OOP语言和OPP语言面对对象编程面对对象编程(Object Oriented Programming, OOP,面对对象程序设计)，它的一条基本原则就是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。 面对对象的程序设计不同于传统的面向过程(OPP)程序设计，它能够欧减低开发难度。 面向过程编程面向过程与面向对象明显的不同就是封装、继承、类。 “面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，他们不支持丰富的“面向对象”特性（比如继承、多态），并且它们不允许混合持久化状态和域逻辑 举个例子来区分两者：比如以百度百科上的公共汽车为例 “面向过程”就是汽车启动是一个事件，汽车到站是另一个事件。在编程序的时候我们关心的是某一个事件。而不是汽车本身。我们分别对启动和到站编写程序。类似的还有修理等等。 “面向对象”需要建立一个汽车的实体，由实体引发事件。我们关心的是由汽车抽象成的对象,这个对象有自己的属性,像轮胎,颜色等;有自己的方法,像启动,行驶等.方法也就是汽车的行为.而不是汽车的每个事件。使用的时候需要建立一个汽车对象，然后进行应用。 OOP的灵魂OOP的关键性观念是它将数据及对数据的操作行为放在一起，作为一个相互依存、不可分割的整体—对象,对于相同类型的对象进行分类、抽象后，得出共同的特征而形成了—类。面向对象编程就是定义这些类。类是描述相同类型的对象集合。类定义好之后将作为数据类型用于创建类的对象。程序的执行表现为一组对象之间的交互通信。对象之间通过公共接口进行通信，从而完成系统功能。类中声明的public成员组成了对象的对外公共接口1。 OOP常用术语抽象与实现(实例化)&emsp; 抽象是对现实世界和实体的本质表现、行为和特征建模，建立一个相关的子集，这个子集不仅具有这种模型的数据属性，而且还定义了这种数据操作的接口。对于抽象数据的实现，就是对此数据及接口的现实化(relization)。 封装与接口&emsp;封装描述了对数据、信息进行隐藏的概念，他对数据属性提供接口和访问函数，客户端无需知道封装之后数据是如何组织的， 合成&emsp;合成扩充了对类的描述，使得多个不同的类合成为一个大的类，来解决现实问题。合成存在两种方式 通过联合关系组在一块，就是说对子组件的访问是被允许的。 通过聚合在一起，封装的组件仅能通过定义好的接口进行访问。 派生与继承、继承结构 派生描述了子类的创建，新类保留已存类类型中所有需要的数据和行为，但允许修改或其他的自定义操作，都不会修改原类的定义。 继承描述了子类属性从祖先类继承这样一种方式。 继承结构表示多“代”派生，可以描述成一个“族谱”，连续的子类和祖先类都有关系。 泛化与特化泛化表示所有子类与其父类和祖先类有一样的特点特化是子类和祖先类的不同，及子类的自定义 多态多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法 多态支出指出了对象如何通过他们共同的属性和动作来操作访问的。而不需考虑他们具体的类。多态表明动态（运行时）绑定的存在，允许重载及运行时类型确定和验证。 重载是一种多态，简单说，重载就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。 多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。如果一个语言只支持类而不支持多态，只能说明它是基于对象的，而不是面向对象的 自省/反射自省表示给予你某种能力进行“手工类型检查”的工作，也被称为反射。这个性质展示了对象是如何在运行期间得到自身信息的。比如传给你一个对象你可以查出他有什么功能 python 中的类类的创建Python类的创建使用关键字class+类名进行创建，类名首字母大写是规范。 类的创建123class Firstclass(object): `类文档字符串` # 类的介绍 class_suite #类主体 类名括号里是基类，object是原始类，可以是一个也可以是多个，用于集成其属性。类由所有声明语句类成员定义和数据属性和函数组成。通常在一个模块的顶层进行定义，便于在文件中任何地方使用。 对于python而言累的声明和定义是同时的，声明紧跟着定义。 类的属性属性是一个对象的数据或者函数元素，可以通过句点属性标识.来访问 类属性之和定义的类绑定，与任何实例对象无关。 类的数据属性这种属性仅仅是所定义类的变量，更新只能靠类中的方法，或在主程序其他地方被更新，这种属性是静态变量或者是静态数据。它不依赖任何类实例。相当于C++中static声明定义的变量用处：跟踪与类相关的值。 类的数据属性1234567class A(object): num=1print(A.num)# out:1A.num=A.num+1print A.nuum# out:2 # 类的数据属性被更新了 类的函数属性类的函数属性仅应用在类的对象(实例上)，对于python 没有实例方法不能被调用，这是Python中的绑定概念。不关是否绑定都是类的固有属性。 类函数属性的定义及调用123456class Myclass(object): def foo(self): print('hello world')mc=Myclass()mc.foo()# Out:'hello world' 而foo()和Myclass.foo()都会调用失败。 查看类的所有属性可以使用内建函数dir()或者类的字典属性进行访问。比如上一个查看上一个类Myclass的所有属性，我们可以使用一下代码查看类的属性1234567891011121314151617181920212223242526272829dir(Myclass)#下面输出结果['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'foo'] 或者使用Myclass.__dict__1234567Myclass.__dict__# 输出mappingproxy(&#123;'__dict__': &lt;attribute '__dict__' of 'Myclass' objects&gt;, '__doc__': None, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'Myclass' objects&gt;, 'foo': &lt;function __main__.Myclass.foo&gt;&#125;) 可以看出dir()更为强壮💪 特殊的类属性对于所有类A ,存在特殊属性如下 属性 介绍 A.__name__ 类的名字（字符串） A.__class__ 实例A对应的类，在新式类中 A.__doc__ 类A的文档字符串 A.__bases__ 类A的所有父类构成的元组 A.__dict__ 类A的所有属性返回字典 A.__module__ 类A定义所在的模块 比如__name__属性，我们之前有遇到过使用type()函数判断对象的类型，此函数返回的是一个类型对象，看如下代码就会明白 type()与__name__属性12345&gt;&gt;&gt; stype=type('hello world')&gt;&gt;&gt; stype&lt;type 'str'&gt;&gt;&gt;&gt; stype.__name__'str' 又比如__module__属性 __module__属性12345&gt;&gt;&gt; from myclass import Myclass&gt;&gt;&gt; Myclass&lt;class myclass.Myclass at 0x55eea&gt;&gt;&gt;&gt; Myclass.__module__'myclass' 其中__doc__属性是类的文档字符串，紧跟头行，不能被派生继承，派生类必须含有他们自己的文档字符串。 python中的对象(实例)实例化默认初始化python创建实例相比于其他语言简单些初始化123&gt;&gt;&gt; class Myclass(object): # 定义类 pass &gt;&gt;&gt; mc=Myclass() # 实例化 __init__()构造器方法当类被调用时，第一步是创建类对象，然后检查是否存在__init__()特殊函数，如果存在则进行调用。实例对象作为第一个参数（self）被传递进去，像标准方法一样，调用类时，传进的任何参数都会交给__init__()。不存在则返回他的对象，实例化完毕。 可以想象为__init__()是解释器喂你创建一个实例后调用的第一个方法，是你调用实例前的准备工作。`__init__()`是很多为类定义的特殊方法之一，其中一些特殊方法是预定义的，缺省情况下，不进行任何操作。 __new__()构造器方法与上一个相比，它更像一个构造器。和__init__的不同可以参考这篇文章：http://python.jobbole.com/86506/ 讲的很详细。其中一段代码证明__new__()先于__init__()执行1234567891011121314151617181920# -*- coding: utf-8 -*- class Person(object): """Silly Person""" def __new__(cls, name, age): print '__new__ called.' return super(Person, cls).__new__(cls, name, age) def __init__(self, name, age): print '__init__ called.' self.name = name self.age = age def __str__(self): return '&lt;Person: %s(%s)&gt;' % (self.name, self.age) if __name__ == '__main__': piglei = Person('piglei', 24) print piglei __new__()都是类方法，第一个参数传入的是此类,此外他还需要返回值 __init__()是类方法但是第一个参数传入的是实例 实例属性使用__init__()时 我们可以传入默认参数，这样我们可以不必现显式给构造器传值了，不存在默认值得参数我们称为缺省值，缺省值是我们在实例化时必须输入的。此外使用`init()`时返回值应当为None,即不反回任何对象。 查看实例属性时使用同类一样可以用dir(实例)，也可以用实例.__dict__ 特殊的实例属性:对于任意对象I,仅有两个特殊属性 特殊实例属性 介绍 I.__class__ 实例化I的类 I.__dict__ I的属性 内建类型属性内建类型也想类一样具有的属性，内建类型12345&gt;&gt;&gt; x =1+1j&gt;&gt;&gt; x.__class__'complex'&gt;&gt;&gt; dir(x)#看结果好像没有__dict__,因为内建类型中没有此属性 实例属性VS类属性前面也有提到，类属性和实例无关，类和实例都是名字空间，类是类属性的名字空间，实例则是实例属性的。你可以采用类访问类属性，如果实例没有同名属性的话也可以用实例访问。 属性1234567891011121314151617&gt;&gt;&gt; class Myclass(object):...: x=1 ...: def __init__(self,y,z): ...: self.y=y ...: self.z=z&gt;&gt;&gt; c=Myclass(2,3)&gt;&gt;&gt; Myclass.x1&gt;&gt;&gt; c.y2&gt;&gt;&gt; c.x1&gt;&gt;&gt;c.x=10&gt;&gt;&gt;c.x10&gt;&gt;&gt;Myclass.x1 通过实例访问类需谨慎比如上面的代码通过实例尝试对类的属性进行修改，发现只是徒劳。但是： 如果类属性是可变的那一切都不一样了，比如字典:可变的类属性123456789101112131415&gt;&gt;&gt; class Myclass(object):...: x=&#123;2018:'ILY'&#125;&gt;&gt;&gt;c=Myclass()&gt;&gt;&gt;c.x&#123;2018:'ILY'&#125;&gt;&gt;&gt;c.x[2019]='IVLY'&gt;&gt;&gt;c.x&#123;2018:'ILY',2019:'IVLY'&#125;&gt;&gt;&gt;Myclass.x&#123;2018:'ILY',2019:'IVLY'&#125;&gt;&gt;&gt;c.x[2018]='IVLY'&gt;&gt;&gt;c.x&#123;2018:'IVLY'&#125;&gt;&gt;&gt;Myclass.x&#123;2018:'IVLY'&#125; 因此使用实例属性来试着修改类属性时很危险的,需要类名来修改类属性，当实例属性存在同名的类属性时，实例默认调用的属性为实例属性非类属性，参考下面代码 类属性更新时，再次通过实例调用类属性也会更新。 绑定和方法调用再次阐述绑定（binding)，主要是与方法关联，方法仅仅是类内部定义的函数，(意味着是类属性不是实例属性)，方法只有在其所属类具有实例时，才能被调用。不能被类调用，因为缺少self的值，所以当存在一个实例时，方法才能被认为是绑定到那个实例了。没有实例方法就是未绑定的。任何一个方法定义中的第一个参数都是self,他表示调用此方法的实例对象。 self是什么？self变量用于在类实例方法引用方法绑定的实例（有点绕哈！），因为方法的实例在任何方法调用中总是作为第一个参数传递的，self被选中用来代表实例。你必须在方法声明中放上self。但是我们可以在方法中不适用self哈哈哈！但是这样你不如直接创建一个常规函数，除非你有其他想法。毕竟没有用到实例你放在这里占地啊！ 调用非绑定方法假如存在一个类和一个此类的实例这时，我们可以通过此实例调用绑定函数，self不需要明确传入了，这就是必须声明self对你的好处，当你没有实例并且需要调用非绑定方法时，需要传入一个self参数。 调用非绑定方法的场景123456class EmplAddrBookEntry(AddrBookEntry): 'Employee Address Book Entry class' def __init__(self,nm,ph,em): AddrBookEnry.__init__(self,nm,ph) self.empid=id self.email=em 代码解释：EmplAddrBookEntry是AddrBookEntry的一个子类，我们想直接继承AddrBookEntry的__init__，所以我们可以对父类的这个绑定函数进行调用，苦于没有父类的实例，但是我们有子类的实例self,但是两者差别很小，主要因为我们还没有来的及自定义我们的EmplAddrBookEntry实例，以使他和AddrBookEntry不同，所以我们将子类EmplAddrBookEntry的实例传给父类AddrBookEntry的这个__init__绑定函数充当他的self参数。以上是调用非绑定方法（因为不是实例所以称之为非绑定）的最佳地方了，一旦调用返回，我们就能定义那些与父类不同的仅存在子类中的实例定制了。 静态方法和类方法回忆上面的方法，通常的方法需要一个实例self作为第一个参数，并且对于绑定方法而言self是自动传给这个方法的，而对于类方法而言，需要类而不是实例作为第一个参数，他是有解释器传给方法，类无需特别的命名，类似self，是类本身，不过很多人使用cls作为变量名字经典类中创建静态方法和类方法的例子:通过内建函数staticmethod()和classmethod()函数创建静态方法和类方法12345678910111213141516171819202122class TestStaticMethod: #经典类 def foo(): print('calling static method foo()') foo=staticmethod(foo)class TestClassMethod: #经典类 def foo(cls): print('calling class method foo()') print('foo() is part of class:',cls.__name__) foo=classmethod(foo)&gt;&gt;&gt; tsm=TestStaticMethod()&gt;&gt;&gt; TestStaticMethod.foo()calling static method foo()&gt;&gt;&gt; tsm.foo()calling static method foo()&gt;&gt;&gt; tcm=TestClassMethod()&gt;&gt;&gt; TestClassMethod.foo()calling class method foo()foo() is part of class:TestClassMethod&gt;&gt;&gt; tcm.foo()calling class method foo()foo() is part of class:TestClassMethod 也可以使用修饰符优化以上代码：修饰符优化静态方法和类方法12345678910class TestStaticMethod: #经典类 @staticmethod def foo(): print('calling static method foo()') foo=staticmethod(foo)class TestClassMethod: #经典类 @classmethod def foo(cls): print('calling class method foo()') print('foo() is part of class:',cls.__name__) 修饰符的介绍讲解参考这篇文章：https://coolshell.cn/articles/11265.html2关于静态方法和类方法的区别可以去这篇文章看看https://www.jianshu.com/p/212b6fdb2c503他的这段代码1234567891011121314class Book(object): def __init__(self, title): self.title = title @classmethod def create(cls, title): book = cls(title=title) return bookbook1 = Book("python")book2 = Book.create("python and django")print(book1.title)print(book2.title) 组合这一章节比较简单，为了增加我们类的功能，又避免太多的重复工作，比如已经存在其他类的某些属性是我们需要的，这时我们可以将这些类组合进来，另一种方法是派生，后面我们会讲到，比如下面这个简单例子👇：组合123456class NewAddrBookEntry(object): '新类的定义' def __init__(self,nm,ph): # 定义构造器 self.name=Name(nm) #创建Name类的实例 self.phone=Phone(ph) #创建Phone类的实例 print('产生了新的对象',self.name) 这一张就这样，虽然内容比较少，但是用的地方真的很多，不要轻视😉 子类、派生和继承子类和派生创建子类和创建普通类的语法没有很大差别，关键字+一个类名+一个或多个需要从其中派生的父类子类12class Subclassname(ParentClass1[,ParentClass2,……]): class_suite 如果你的类没有从任何祖类中派生，可以使用object作为父类的名字，经典类的声明唯一不同之处在于其没有从祖先类派生——此时没有圆括号经典类12class ClassicClassWithoutSuperclasses: pass 在一个例子：子类创建1234567891011121314class Parent(object): def par(self): print('父')class Chird(Parent): def chi(self): print('子')&gt;&gt;&gt;p=Parent()&gt;&gt;&gt;c=Chird()&gt;&gt;&gt;p.par()父&gt;&gt;&gt;c.chi()子&gt;&gt;&gt;c.par父 说明派生的子类拥有父类的函数。就是下面讲的继承了 继承继承是说基类的属性是如何遗传给派生类的，一个子类可以继承他的基类的任何属性，不管是数据属性还是方法。 继承的一些属性：12345678910class P: 'p Class' def __init__(self): print('created an instance of ',self.__class__.__name__)class C(P): pass&gt;&gt;&gt; c=C()created an instance of C&gt;&gt;&gt; C.__doc__&gt;&gt;&gt; C中没有声明__init__()方法，是从P中继承来的，实例c被创建时，调用了父类的__init__(self)传入了c实例，c是类C的实例所以最后输出的是created an instance of C 因为特殊属性__doc__不会从基类中继承过来，所以C.__doc__没有输出 __bases__类属性__bases__1234567891011class A: passclass B(object):passclass C(B):passclass D(C):passclass E(C,B):pass&gt;&gt;&gt;A.__bases__(object,)&gt;&gt;&gt;D.__bases__(__main__.C,)&gt;&gt;&gt; E.__bases__(__main__.C, __main__.B) 可以看出爷类不会再bases中展示，E是多重继承后面会讲。 继承覆盖方法我们在子类中再写一个和父类方法一样的方法，可以对父类方法进行覆盖 方法继承和覆盖123456789101112class P(object): def foo(self): print('父')class C(P): def foo(self): print('子')&gt;&gt;&gt; p=P()&gt;&gt;&gt; p.foo()父&gt;&gt;&gt;c=C()&gt;&gt;&gt;c.foo()子 尽管C继承了P的foo方法，但是C中的自定义方法覆盖了父类的foo，原因就是子类想干些其他事情。但是如果我们还想使用父类的方法怎么办呢？把父类的方法当做非绑定方法进行调用，传入c当其self即可 12&gt;&gt;&gt;P.foo(c)父 不需要在建立一个P的实例了，只需对c进行调用即可也可以在子类重写方法中显式添加这一项： 1234class C(P): def foo(self): P.foo(self) print('子') 一个更好的方法就是使用内建函数super() 12345678class C(P): def foo(self): super(C.self).foo() print('子')&gt;&gt;&gt; c=C()&gt;&gt;&gt; c.foo()父子 super()不仅能帮我们找到C的基类而且能够把self传入其中。 重写__init__()不会自动调用基类的__init__() 可以使用: 123456789class C(P): def __init__(self): P.__init__(self) #再添加子类自定义属性# 或者class C(P): def __init__(self): super(C,self).__init__() #再添加子类自定义属性 super()的漂亮之处在于你不需要知道任何基类的名字，跑腿的事他帮你干了，所以当你改变了类继承关系，只需要改class后的那一行即可 从标准类中派生标准类就比如str、int、float等等吧，老版本的python并不能对这些进行子类化，现在早已经修复。 对于不可变类型的例子 比如想把float四舍五入小数点后保留两位， 定制新类小数点后保留两个位1234567class RoundFloat(float): def __new__(cls,val): return float.__new__(cls,round(val,2))## 使用super（）class RoundFloat(float): def __new__(cls,val): return super(RoundFloat,cls).__new__(cls,round(val,2)) 我们覆盖了new()特殊方法来定制我们的对象，使用round()函数进行四舍五入保存两位小数位，然后实例化float,RoundFloat.我们通过调用父构造器来创建真实的对象的，float.new()，所有的new()都是类方法,我们要显式传入类作为第一个参数，类似于方法init()中需要self。最好还是使用super吧上面代码第二个方案。 可变类型的例子 一般可以不适用__new__()甚至__init__()因为设置通常不多，所继承的类型的默认行为就是你想要的，对其进行简单的修改。比如一个对字典排序的例子。1234class SortKeydict(dict): def keys(self): return sorted(super(SortKeydict,self).keys()) # return sorted(self.keys()) 岂不是更简单 多重继承简单属性的查找示例123456789101112131415class P1: #(object:) #父类1 def foo(self): print('P1-foo')class P2:#(object:) #父类2 def foo(self): print('P2-foo') def bar(self): print('P2-bar')class C1(P1,P2): passclass C2(P1,P2): def bar(self): print('C2-bar')class GC(C1,C2): pass 经典类没有从object派生,解释顺序如下： 深度优先，从左到右 经典类顺序12345&gt;&gt;&gt; gc=GC()&gt;&gt;&gt; gc.foo()P1-foo&gt;&gt;&gt; gc.bar()P2-bar 你想调用更近的C2中的函数bar就需要采用典型非绑定方式去调用12&gt;&gt;&gt; C2.bar(gc)C2-bar 新式类 从object派生,解释顺序：广度优先，从左到右 12345&gt;&gt;&gt; gc=GC()&gt;&gt;&gt; gc.foo()P1-foo&gt;&gt;&gt; gc.bar()C2-bar 同样，你想调用P2中的函数bar就需要采用典型非绑定方式去调用 新式类多重继承时会出现菱形效应 类实例和其他对象的内建函数issubclass()用来判断一个类是不是另外一个类的子类或者子孙类Usage:issubclass(sub,sup),返回True的情况：给出的子类sub确实是sup的一个子类，一个类可以视为自身类的子类第二个参数即父类可以选择一个元祖，只要子类是元祖中任何一个类的子类均返回True isinstance()判定一个对象是不是一个类的实例时用到：Usage:isinstanc(obj1,obj2)，如果obj1是obj2的一个实例，或者是obj2的子类中的一个实例，返回True.第二个参数需为类，否则将会出现错误 hasattr()、getattr()、setattr()、delattr()这个系列的函数不限于类和对象，但在类和对象中应用较为广泛。Usage: *attr(obj,’attr’),第一个是处理对象，第二个参数传入属性名。 hasattr()是布朗型的，检查对象时候 getattr()、setattr()可以获取和赋值给对象的属性。 delattr()可以删除对象中的属性123456789101112131415class A(object): def __init__(self): self.foo=1000&gt;&gt;&gt; a=A()&gt;&gt;&gt;hasattr(a,'foo')True&gt;&gt;&gt;getattr(a,'foo')1000&gt;&gt;&gt;getattr(a,'bar','bar!')bar!&gt;&gt;&gt;getattr(a,'bar')AttributeError: 'A' object has no attribute 'bar'&gt;&gt;&gt;setattr(a,'bar','newbar')&gt;&gt;&gt;getattr(a,'bar')newbar dir()列出一个模块中所有属性信息Usage: dir(obj),不仅可以作用到类上，亦可以作用到对象上。 super()这个函数帮助程序员找到父类，一般情况下程序员仅能通过调用非绑定方法调用祖类方法，使用super()可以简化搜索一个合适的祖先的任务，并且调用他时能够传入实例或类型对象。之前也有用到。Usage:super(type[,obj])返回的回一个super类， var()var()内建函数和dir()类似，只是给定的对象必须有一个__dict__属性，var()返回一个字典，它包含了对象存于__dict__中的属性和值，如果没有__dict__则会异常 参考链接1.参考百度百科“OOP”链接 ↩2.https://coolshell.cn/articles/11265.html ↩3.https://www.jianshu.com/p/212b6fdb2c50 ↩4.主要参考《python核心编程》不错的一本书 ↩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度壁纸的小爬虫]]></title>
    <url>%2F2018%2F01%2F19%2F%E7%99%BE%E5%BA%A6%E5%A3%81%E7%BA%B8%E7%9A%84%E5%B0%8F%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[一个基于python的百度小爬虫脚本 正当我准备爬百度壁纸的时候，好像就出现了崩溃。😑😑😑 好吧那我等一会看行不行吧，先吃个中午饭去。 发现是浏览器的问题，从Safari浏览器换成Chrome浏览器就好了。所以一条路行不通，要换条路，不要一棵树上掉死😑。 正题开始准备工作 抓包工具Charles,图标是这个-&gt; 也有类似的其他工具，比如Wireshark。这里我们不在介绍，感兴趣的可以自己Google。 这个爬虫之所以要使用抓包工具，是因为，百度壁纸不是分页显示的，那样的话我们可以根据不同的URL进行爬取，它是根据鼠标下滑是加载实现的，URL是同一个，但是，但是hiahia根据抓包工具我们可以发下当我们下滑是那些东西发生了变化，然后找到规律进行爬取。 先来看看页面加载的变化这个是百度壁纸打开后的URL:初始URL1http://image.baidu.com/search/index?ct=201326592&amp;tn=baiduimage&amp;word=%E5%A3%81%E7%BA%B8&amp;pn=0&amp;ie=utf-8&amp;oe=utf-8&amp;cl=2&amp;lm=-1&amp;fr=ala&amp;se=&amp;sme= 不管你怎么下滑看图片，这个URL都不会发生变化，那如果我们爬图片仅仅爬这个URL就只能得到一点图片，而不是一万张图片。😑 打开Charles,界面就是这样，顶部是菜单栏，当我们打开网页是左侧会自动增加我们请求信息以及反馈信息。据此可以进行抓包分析。 比如当我们打开百度壁纸页时，下滑查看更多图片，抓包工具就抓到了相应的请求信息： 接下来我们进行分析这些请求🤔 此时需配上这首BGM 🤔仔细端详一下URL 🤔噫！ 我们发现虽然表面URL没变化，实际请求时确发生了变化，而且只是一个特定的值发生了变化那就是pn。所以我们爬取的时候应该以实际的URL进行操作 这样才能爬到更多图片😍 代码分步介绍百度壁纸又炸了，看来不是浏览器的问题😂 上代码前先回顾一下简单的爬虫知识，毕竟从小白过来的，巩固一下也是好的. URL中文编译使用urllib爬虫库,重要的函数有urllib.request,urllib.parse,urllib.request.quote等，下面用到我们再细讲。URL存在中文时需要使用quote函数编码一下，比如我们百度搜索关键字时的URL设定是这样子的http://www.baidu.com/s?wd=壁纸这时候就需要我们将‘壁纸’编码一下： 编译中文123456789101112131415# -*- coding: utf-8 -*-## 使用python3.6版本__author__="ddc"import urllib.request as urimport urllib.parseurl='http://www.baidu.com/s?wd=' key='望川秋酷'key_code=ur.quote(key)url_all=url+key_codereq=ur.Request(url_all)data=ur.urlopen(req).read()print(data) 添加headers有两种方式添加headers 方案一12345678url='http://www.baidu.com'req=ur.Request(url)req.add_header('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36')data=ur.urlopen(req).read()print(data) 方案二123456789import urllib.request as ururl='http://www.baidu.com'headers=('User-Agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36')opener=ur.build_opener()opener.addheaders=[headers]data=opener.open(url).read()#print(data) 添加IP代理添加代理123456789import urllib.parseimport urllib.request as urproxy=urllib.request.ProxyHandler(&#123;'http':"202.108.2.42:80"&#125;)opener=ur.build_opener(proxy,ur.HTTPHandler)opener.addheaders=[headers] # 添加headersur.install_opener(opener) # 安装data=ur.urlopen(url).read() # 读取数据print(data) 百度URL命名规律上面这两个添加了基本可以解决百度壁纸爬取的问题了，下面看一下壁纸URL的命名规律 看完这两张图，想必你也明白了什么吧。 首先是壁纸这个关键词然后两个%20包括大分类接着一个小分类名 可以自由设定爬取特定对象，这里直接爬取全部据此我们可以写一个获取URL代码： 获取url代码函数1234567891011121314151617def geturl(keyword,classname=None,subclassname=None,pn=0): if type(pn)!=int: print('Error:pn is not an int') return none if not classname: key_code=ur.quote(keyword) url="http://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%s&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;word=%s&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=&amp;fr=&amp;pn=%s&amp;rn=30&amp;itg=1&amp;gsm=1e&amp;1516354255134="%(key_code,key_code,pn) elif not subclassname: class_code=ur.quote(classname) key_code=ur.quote(keyword) url="http://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%s+%s&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;word=%s+%s&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=&amp;fr=&amp;pn=%s&amp;rn=30&amp;itg=1&amp;gsm=1e&amp;1516354255134="%(key_code,class_code,key_code,class_code,pn) else: class_code=ur.quote(classname) key_code=ur.quote(keyword) sub_code=ur.quote(subclassname) url="http://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%s+%s+%s&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;word=%s+%s+%s&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=&amp;fr=&amp;pn=%s&amp;rn=30&amp;itg=1&amp;gsm=1e&amp;1516354255134="%(key_code,class_code,sub_code,key_code,class_code,sub_code,pn) return url 百度壁纸真的是炸了，链接都打不开了，哎先把代码搞上，好了再试。 获取图片链接分析网页中图片的链接规律利用正则表达式进行匹配，代码如下 获取图片链接地址12345def getimgurls(data): reg='\[\&#123;"ObjURL":"(.*?)"' imglist= re.compile(reg).findall(data.decode('utf-8'),re.I) imglist=[i.replace('\\','') for i in imglist] return imglist 结果如下： 获取多个网页图片链接这是用到之前抓包分析的东西，即修改pn的值，以及我们可以自定义搜索类和子类，这里我分别设定为卡通动漫，动漫美女可以自行修改但是要按照壁纸页里的类进行修改。 多页图片链接保存12345678910111213## 获取图片链接imgurls=[]for i in range(1,4): pn=i*30 htmlurl=geturl(keyword='壁纸',classname='卡通动漫',subclassname='动漫美女',pn=pn) headers=('User-Agent','Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36') opener=ur.build_opener() opener.addheaders=[headers] ur.install_opener(opener) data=opener.open(htmlurl).read() imgurls+=getimgurls(data)len(imgurls) ## 查看链接列表的长度 图片下载这一步很简单直接调用函数即可：下载图片12path='/users/ddc/desktop/壁纸/动漫美女/' #设定保存位置downpic(path,imgurls) 总代码百度壁纸小爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: utf-8 -*-__author__="ddc"import urllib.request as urimport urllib.parseimport reimport osimport timeimport socketclass Wallpaperspider(object): def __init__(self,path='C://壁纸/',classname=None,subclassname=None,pn=4,keyword='壁纸'): self.classname=classname self.subclassname=subclassname self.keyword=keyword self.path=path self.pn=pn def geturl(self,pn): if type(pn)!=int: print('Error:pn is not an int') return none if not self.classname: key_code=ur.quote(self.keyword) url="http://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%s&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;word=%s&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=&amp;fr=&amp;pn=%s&amp;rn=30&amp;itg=1&amp;gsm=1e&amp;1516354255134="%(key_code,key_code,pn) elif not self.subclassname: class_code=ur.quote(self.classname) key_code=ur.quote(self.keyword) url="http://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%s+%s&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;word=%s+%s&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=&amp;fr=&amp;pn=%s&amp;rn=30&amp;itg=1&amp;gsm=1e&amp;1516354255134="%(key_code,class_code,key_code,class_code,pn) else: class_code=ur.quote(self.classname) key_code=ur.quote(self.keyword) sub_code=ur.quote(self.subclassname) url="http://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%s+%s+%s&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;word=%s+%s+%s&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=&amp;fr=&amp;pn=%s&amp;rn=30&amp;itg=1&amp;gsm=1e&amp;1516354255134="%(key_code,class_code,sub_code,key_code,class_code,sub_code,pn) return url def getimgurls(self,data): reg='\[\&#123;"ObjURL":"(.*?)"' imglist= re.compile(reg).findall(data.decode('utf-8'),re.I) imglist=[i.replace('\\','') for i in imglist] return imglist def moreimgurls(self): imgurls=[] for i in range(1,self.pn): pn=i*30 htmlurl=self.geturl(pn) headers=('User-Agent','Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36') opener=ur.build_opener() opener.addheaders=[headers] ur.install_opener(opener) data=opener.open(htmlurl).read() imgurls+=self.getimgurls(data) self.imgurls=imgurls return self.imgurls def downpic(self): self.moreimgurls() pici=1 if not os.path.isdir(self.path): os.mkdir(self.path) headers=('User-Agent','Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36') opener=ur.build_opener() opener.addheaders=[headers] ur.install_opener(opener) for imgurl in self.imgurls: pathname=self.path+imgurl[-38:-16]+'.jpg' print('你正在下载第%s张图片...'%pici) try: socket.setdefaulttimeout(15) #超时设定15秒 ur.urlretrieve(imgurl,pathname) pici+=1 except socket.error: print("下载超时") except Exception as e: print("未成功下载",imgurl) continue time.sleep(1) allnum=pici-1 print('总共下载了%s张图片'%allnum) return allnumdown=Wallpaperspider(classname='不同风格',subclassname='风景',pn=3)down.downpic() 爬取结果：这么多图片够我文章封面用的了✌ 小福利这次爬取了300张照片，限于流量，没敢多下载，上几张不错的照片吧]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python递归列举所有文件]]></title>
    <url>%2F2018%2F01%2F18%2Fpython%E9%80%92%E5%BD%92%E5%88%97%E4%B8%BE%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用递归列举特定目录下的全部文件 老习惯上代码列举所有文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!usr/bin/python#-*- coding:utf-8 -*-__author__='ddc'import ospath="/Users/ddc/Desktop/B10003012fj" #定义路径global dir_numdir_num=0 #递归函数执行次数def Listdir(path,fullname=False): #dir_num=0 #文件夹的数量 global dir_num dir_num+=1 a=' '*dir_num if not fullname: if os.listdir(path): for f_d in os.listdir(path): p_con=os.path.join(path,f_d) if os.path.isfile(p_con): print(a+f_d) #打印文件名 else: if os.path.isdir(p_con): print(' '*(dir_num-1)+'----'+f_d) #打印文件夹名 Listdir(p_con) #递归打印文件夹下所有文件 dir_num-=1 #保持下次的格式能够与之前的文件夹位置相同 else: print(a+'空') else: if os.listdir(path): for f_d in os.listdir(path): p_con=os.path.join(path,f_d) if os.path.isfile(p_con): print(a+p_con) else: if os.path.isdir(p_con): print(' '*(dir_num-1)+'----'+p_con) Listdir(p_con,fullname=True) dir_num-=1 else: print(a+'空') Listdir(path,fullname=False) 解释这次代码知识定义一个函数，函数参数有：需要列举的文件目录，以及一个是否以绝对地址的方式显示即布尔变量fullname。 首先定义一个全局变量 dir_num，这样函数在调用本身的时候这个值也会产生变化。即dir_num+=1 文件和文件夹要区分开这时候需要使用一个判断语句，来判断内容是文件还是文件夹，如果是文件夹则需要继续进入其中回调本函数，如果是文件则直接打印即可 打印的格式 定义了一个变量a来排版打印的格式，a的空格数和文件的深度（即层数）成正比，文件夹藏的越深🤔空格数就越多 此外打印文件夹名时，空格换成了横线，便于区分文件和文件夹 输出结果首先文件夹的实际内容：运行程序得到的结果 哈哈哈发现没有隐藏文件： .DS_Store .out00-PKG.pkg.icloud .out00-PYZ.pyz.icloud .xref-modelock.html.icloud 都给你整出来了🙃😱💩💩]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Literature-note2]]></title>
    <url>%2F2018%2F01%2F17%2FLiterature-note2%2F</url>
    <content type="text"><![CDATA[文献：《Ultrafast laser mode-locked using nonlinear polarization evolution in polarization maintaining fibers》 ForewordNPE modelockDefinition: the phenomenon that the change in the polarization direction of light in a fiber can depend on the optical intensity The polarizing isolator placed between two polarization controllers acts as the mode-locking element. It plays the double role of an isolator and a polarizer such that light leaving the isolator is linearly polarized. Consider a linearly polarized pulse just after the isolator. The polarization controller placed after the isolator changes the polarization state to elliptical. The polarization state evolves nonlinearly during propagation of the pulse because of SPM- and XPM-induced phase shifts imposed on the orthogonally polarized components. The state of polarization is non-uniform across the pulse because of the intensity dependence of the nonlinear phase shift. The second polarization controller (one before the isolator) is adjusted such that it forces the polarization to be linear in the central part of the pulse. The polarizing isolator lets the central intense part of the pulse pass but blocks (absorbs) the low-intensity pulse wings. The net result is that the pulse is slightly shortened after one round trip inside the ring cavity, an effect identical to that produced by a fast saturable absorber. In other word, the polarization-dependent isolator, working together with the birefringence fiber, can generate an intensity-dependent loss, which is identical to that produced by a fast saturable absorber. Ultra-high-energy pulse generation based on NPE modelock Normal soliton is maintained by the balance of a negative dispersion and the fiber nonlinearity, giving a pulse operation of fixed energy. As a result, pump level increase usually can only vary the repetition rate of the laser instead of enlarging the pulse energy gain-guided soliton, usually with the cavity dispersion purely positive or totally positive, is maintained through the balance of gain and nonlinear loss of cavity.In this lasers, soliton effects which tend to shape the pulses to a given shape and energy can be much weaker, and in this case enhancing the pump power will indeed greatly enlarge the per-pulse energy. Expriment and resultsIt is an Yb-doped fiber laser with a cavity length of 8 km. The light is output from the cavity via a fiber polarization splitter. The Yb-doped fiber serves as the active medium of the laser that is pumped via a multi-mode coreless fiber. The length of the active Yb-doped fiber is 10 m, and the core diameter is 7 μm. The active fiber is pumped by a multimode diode laser with an output power of up to 1.5 W at a wavelength of 980 nm. Mode-locking can be readily realized by simply tuning the polarization controllers inside the cavity. Fig.3 shows the typical auto-correction trace of generated pulses. It is a 170 ps pulse train with 37k Hz repetition rate and per-pulse energy of 4 μJ. ConclusionChoosing the gain-guided operation state which can bypass the soliton restriction of per-pulse energy, together with effectively enhance the cavity length, ultra-high energy pulse up to several μJ can be directly generated from the laser. The results also demonstrate the posibility of generating mode-locking of ultra-long cavity ReferenceXu, H. (n.d.). Nonlinear Polarization Rotation for Fiber Lasers with Ultra­High Pulse Energy,Retrieved from:http://www.phys.unm.edu/msbahae/physics568/studentpapers2011/Xu.pdf another article&emsp;All-fiber ultrafast os- cillators can be designed and mode-locked with various types of saturable absorbers (SAs). Materials such as graphene , carbon nanotubes , and even alcohol can be used for this purpose. Alternatively, then this article introduced the trandional NPE modelock&emsp;Traditionally, the NPE mode-locking technique in an all-fiber cavity is implemented with standard single-mode non-PM fibers accompanied by polarization con- trollers that prepare elliptical polarization. The orientation of the major axis of the polarization ellipse rotates during propa- gation in the fiber due to the nonlinear Kerr effect. After the propagation, a polarizer is used to filter the polarization state. The angle of the rotation and, therefore, the transmission of the setup is light intensity dependent—an artificial SA is formed. In this approach, the input polarization state has to be carefully adjusted in order to achieve the desired SA characteristics. Because of that, the mode locking is sensitive to thermal and/or mechanical stress which results in poor resistance of the laser to environmental perturbations. some method to reduce NPE disadvantages.&emsp;An attempt to increase the environmental stability of an NPE-based fiber laser by placing a fiber between a Faraday ro tator and Faraday mirror (FM) has been made in : M. E. Fermann, L.-M. Yang, M. J. Andrejco, and M. L. Stock, Opt. Lett. 19, M. E. Fermann, K. Sugden, and I. Bennion, Opt. Lett. 20, 1625 (1995)Wang et al. proposed an NPE mode-locked ring cavity based on PM fibers: Y. Wang, L. Zhang, Z. Zhuo, and S. Guo, Appl. Opt. 55, 5766 (2016)read later &emsp;Another attempt to realize the NPE with increased environmental stability (with use of PM fibers only) was presented by Nielsen and Keiding principle A two-fiber section scheme with a single 90° splice [see Fig. 1(a)] is not an optimal solution: one of the two pulses created at the first angle splice is leading through all the NPE section. This means that the falling edge of the lagging pulse is never influenced by the rising edge of the leading pulse, while the falling edge of the leading pulse interacts with the rising edge of the lagging pulse. As a consequence, the spectrum and the time profile of the output pulse become ragged and in the extreme case multiple pulses are created (see Fig. 2). To avoid this, one might divide the fiber stretch into three parts [Fig. 1(b)]. The first and the last section are twice as short asthe central one. This assures that the lagging pulse will take the lead in the center of the middle fiber piece. Ourmodel relies on unidirectional pulse propagation equation approach： M. Kolesik and J. V. Moloney, Phys. Rev. E 70, 036604 (2004). 22. SummarizeTo summarize, in this Letter, we have demonstrated for the first time, to the best to our knowledge, a femtosecond all-PM fiber oscillator mode-locked by a NPE process in standard PM fibers. The laser operated at 1032 nm and was capable of gen- erating ultrashort pulses with the dechirped pulse duration of ∼150 fs at a 20.54 MHz repetition rate. The maximum achieved average output power of 17.5 mW corresponds to ∼0.85 nJ of output pulse energy ReferenceSzczepanek, J., Kardaś, T. M., Radzewicz, C., &amp; Stepanenko, Y. (2017). Ultrafast laser mode-locked using nonlinear polarization evolution in polarization maintaining fibers. Optics Letters, 42(3), 575. https://doi.org/10.1364/OL.42.000575]]></content>
      <categories>
        <category>老本行</category>
        <category>文献笔记</category>
      </categories>
      <tags>
        <tag>Laser</tag>
        <tag>文献</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[liteature-note1]]></title>
    <url>%2F2018%2F01%2F16%2Fliteature-note1%2F</url>
    <content type="text"><![CDATA[文献：《Divided-pulse amplification of ultrashort pulses》© 2007 Optical Society of America Abstract The divided-pulse amplification is a new approach, to the best of our knowledge, fot avoiding nonlinear effects in the amplification of ultrashort optical pulses. The initial pulse is divided longitudinally into a sequence of lower-energy pulses that are otherwise identical to the original, except for the polarization. The low- intensity pulses are amplified and then recombined to create a final intense pulse. Main points in paperCPA(Chirped Pulse Amplification)A pulse is stretched temporally by a dispersive delay time. The stretched (thus frequency-chirped) pulse is amplified, and then the pulse is dechirped to its initial duration in another dispersive delay line. In practice, it is difficult to stretch and compress a picosecond pulse with high fidelity Practical devices that provide enough disper- sion to stretch and compress high-energy pulses longer than a few picoseconds do not exist. DPA(Divided-Pulse Amplificatio)The original pulse is divided into N copies of itself, which do not overlap temporally. The N pulses are amplified, and then recombined to produce the fi- nal intense pulse The crystals at odd- numbered positions in the sequence have their optic axes oriented at a 45° angle to the direction of linear polarization of the pulse to be amplified, while those at the even-numbered positions are oriented in the same direction as the polarization. At each crystal, a pulse is split into two equal-intensity pulses, one or- dinary (o) wave and one extraordinary (e) wave. The o and e pulses are separated in time by $\Delta_t=|1/v_e-1/v_o|L$, where vo and ve are the group velocities of the o and e waves, and L is the crystal length. The length of the shortest crystal (which we take as the first crystal, L1) is chosen so that $\Delta_t$ exceeds the pulse duration. To produce equally spaced pulses, thelength of the mth crystal in the sequence should be $L_m=2^{m−1}L1$. A sequence of M crystals splits the original pulse into $2^M$ pulses, with orthogonal linear polarizations. The amplified pulses can be recombined in a sequence of crystals similar to the one that divided the pulses. Expriment Results SomePoints They noted that it is not necessary to match the lengths of divider and recombiner crystals to subwavelength accuracy, because pulses with orthogonal polarizations recombine. Mismatch of the lengths will produce elliptical polarization across the edges of the pulse but not destructive interference. The duration will increase proportionally to the length mismatch. A simple approach might be to choose birefringent materials with small GVD. DPA is ideally suited to polarization-insensitive amplifiers such as the fiber demonstrated here. However, DPA can also be adapted to polarization-sensitive amplifiers by separating two parts, which both have linear polarization ReferenceZhou, S., Ouzounov, D. G., &amp; Wise, F. W. (2007). Divided-pulse amplification of ultrashort pulses. Conference on Lasers and Electro-Optics, 2007, CLEO 2007, 32(7), 871–873.https://doi.org/10.1109/CLEO.2007.4453041]]></content>
      <categories>
        <category>老本行</category>
        <category>文献笔记</category>
      </categories>
      <tags>
        <tag>Laser</tag>
        <tag>Literature</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲线去掉锯齿利用卷积np.convolve函数平滑]]></title>
    <url>%2F2018%2F01%2F15%2F%E6%9B%B2%E7%BA%BF%E5%8E%BB%E6%8E%89%E9%94%AF%E9%BD%BF%E5%88%A9%E7%94%A8%E5%8D%B7%E7%A7%AFnp.convolve%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[使用卷积积分平滑曲线最终效果如下 直接上代码吧代码如下： 卷积平滑曲线1234567891011121314151617181920212223# 导入相应库函数import numpy as npimport matplotlib.pyplot as pltplt.rc('font',family="Microsoft YaHei",size=16)plt.rc('lines',lw=3)## 平滑曲线data=np.loadtxt('286-189-600ps.txt',skiprows=15) # 导入数据 二维数据# set the windows' sizeN=3 # 卷积参数，越大越平滑weights=np.ones(N)/N # set the weight factorsc = data[:,1]ma = np.convolve(weights, c)[N-1:-N+1] #卷积运算t = data[:,0][np.arange(N-1, len(c))]# 结果作图：plt.figure(figsize=(12,8))plt.plot(t, c[N-1:],'b-', lw=1.0,label='原图')plt.plot(t, ma, 'r-',lw=2.0,label='卷积平滑后')plt.legend(fontsize=20)plt.grid()plt.show() 结果]]></content>
      <categories>
        <category>Python</category>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy使用笔记]]></title>
    <url>%2F2018%2F01%2F15%2Fnumpy%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录Numpy库使用中常用代码及命令 导入数据loadtxt函数一般txt数据头部都会有一些信息，我们只需要数据头部信息需要舍去，这是需要在loadtxt函数中添加skiprows属性，用法如下： numpy导入txt数据12import numpy as npdata=np.loadtxt('pathtodata',skiprows=10) ##pathtodata即数据所在位置，可以是相对位置，跳过行数为10 loadtxt函数还可以导入csv格式，csv格式的文件，单行数据之间存在”,“分隔符,这是代码需要修改成 12import numpy as npdata=np.loadtxt('pathtodata',delimiter=",",skiprows=1) 保存csv格式的文件代码如下：1numpy.savetxt('new.csv', data, delimiter = ',') 数组合并方法不要多，只要够用就行，比如可以使用append方法进行合并 数组合并1234567import numpya=np.random.rand(3) # np.random.rand(4,3)可以生成矩阵b=np.random.rand(3) c=np.append(a,b)carray([ 0.71791648, 0.61480232, 0.19150794, 0.86219832, 0.72884011, 0.0878988 ]) 寻找最大值最小值索引函数numpy中有两个函数argmin,argmax，可以分别寻找序列的最小值和最大值的索引 12345a=np.linspace(2,10,8)# a=[ 2. ,3.14285714,4.28571429,5.42857143 6.57142857,7.71428571,8.85714286 ,10. ]c=np.argmin(abs(a-5))#c=3]]></content>
      <categories>
        <category>Python</category>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云使用Nginx部署hexo]]></title>
    <url>%2F2018%2F01%2F14%2F%E8%85%BE%E8%AE%AF%E4%BA%91%E4%BD%BF%E7%94%A8Nginx%E9%83%A8%E7%BD%B2hexo%2F</url>
    <content type="text"><![CDATA[主要介绍怎么远程连接腾讯云主机ubuntu,使用Nginx部署个人博客hexo 基于Ubuntu系统的Nginx安装之前腾讯云有学生优惠活动，本人在那买了一个一元云主机，虽然性能很一般，但是足以搭一个个人博客。 首先使用hexo生成自己的静态博客，关于hexo的安装和使用参见我的其他博客。 静态博客需要部署到腾讯云，安装一个简单而且功能能够满足要求的Nginx 安装Nginx的依赖库安装gcc g++的依赖库 ubuntu可以使用一下命令 安装命令12apt-get install build-essentialapt-get install libtool 安装 pcre依赖库 命令如下： 安装命令12sudo apt-get updatesudo apt-get install libpcre3 libpcre3-dev 安装 zlib依赖库 命令如下： 安装命令 1apt-get install zlib1g-dev 安装 ssl依赖库 命令如下： 安装命令 1apt-get install openssl 安装Nginx命令如下： 安装命令1apt-get install openssl 在腾讯云Ubuntu主机上默认安装位置在 /etc/nginx 在此目录下可以使用命令：重启服务器1sudo service nginx restart 重启服务器，此命令后面部署时会经常用到。 设置ssh免密连接云主机对于网络小白的我，此部分花费了我不少功夫，此部分对于我来说还要必须设置，否则部署更新的时候会出现连接错误。 对ssh的理解对于ssh之我的理解 使用密码登录，每次都必须输入密码，感觉太浪费时间，而且非常麻烦。尤其是密码超级复杂，维护的服务器又比较多的情况下。好在SSH还提供了公钥（public key）登录，可以省去输入密码的步骤。所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。基于密钥的安全验证必须为用户自己创建一对密钥，并把共有的密钥放在需要访问的服务器上。当需要连接到SSH服务器上时，客户端软件就会向服务器发出请求，请求使用客户端的密钥进行安全验证。服务器收到请求之后，先在该用户的根目录下寻找共有密钥，然后把它和发送过来的公有密钥进行比较。如果两个密钥一致，服务器就用公有的密钥加密“质询”，并把它发送给客户端软件（putty,xshell等）。客户端收到质询之后，就可以用本地的私人密钥解密再把它发送给服务器，这种方式是相当安全的。 步骤： 1、在客户端生成一对密钥 2、将公钥传输至服务器端某用户的家目录下的 .ssh/authorized_keys 文件中（多个公钥需要进行追加） 3、测试登录 首先看简单的一种方式图： 假设存在一个个人PC:A要ssh连接到主机B上，即B上的数据要发送到A上，有以下几步需要走： 首先 接收方 生成一对密钥，即私钥和公钥； 然后，接收方 将公钥发送给 发送方； 发送方用收到的公钥对数据加密，再发送给接收方； 接收方收到数据后，使用自己的私钥解密。 第二种带有密钥的ssh上图： 首先，发送方B使用对称算法对原始信息进行加密。 接收方A通过公钥机制生成一对密钥，一个公钥，一个私钥。 接收方A将公钥发送给 发送方B。 发送方B用公钥对对称算法的密钥进行加密，并发送给接收方A。 接收方A用私钥进行解密得到对称算法的密钥。 发送方B再把已加密的原始信息发送给接收方A。 接收方A使用对称算法的密钥进行解密。 ssh连接云主机过程如下： 远程主机收到用户的登录请求，把自己的公钥发给用户； 用户使用这个公钥，将登录密码加密后，发送回来； 远程主机用自己的私钥，解密登录密码（是事先从用户拷贝过去的），如果密码正确，就同意用户登录。 ssh默认端口为22，可以根据自己的需要修改默认端口号为其它，并配合使用iptables过滤来限制远程SSH登陆的ip。常用用法如下： 修改端口1234# 使用默认的22端口ssh root@192.168.0.1# 若修改过SSH默认端口号（例如：修改为了1000），则登陆时需要指定端口号10000ssh root@192.168.0.1 -p 10000 配置SSH免密登录Ubuntu运行过程中需要管理远端Ubuntu守护进程，在Ubuntu启动以后，NameNode是通过SSH（Secure Shell）来启动和停止各个DataNode上的各种守护进程的。这就必须在节点之间执行指令的时候是不需要输入密码的形式，故我们需要配置SSH运用无密码公钥认证的形式，这样NameNode使用SSH无密码登录并启动DataName进程，同样原理，DataNode上也能使用SSH无密码登录到 NameNode。 首先，运行 ssh localhost 来产生 /home/用户名/.ssh 目录，然后执行下面命令，将生成的 “ id_rsa.pub ” 追加（这里切记是追加，不是覆盖）到授权的key里面去。这样的效果是实现了当前用户无密SSH登陆到自己： 1234cd ~/.ssh # 如果找不到这个文件夹，先执行一下 &quot;ssh localhost&quot;ssh-keygen -t rsa# 将id_rsa.pub追加到authorized_keyscat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 如果要实现无密登陆到其它的主机，只需将生成的 “ id_rsa.pub “ 追加到其它主机的 ” ~/.ssh/authorized_keys “ 中去。这里我们使用的方法是先将本机的 ” ~/.ssh/id_rsa.pub “ 拷贝到你想无密登陆的主机上，再在相应的主机上使用 ” cat “ 命令将” ~/.ssh/id_rsa.pub “ 追加到该主机的 ” ~/.ssh/authorized_keys “ 中。 123456789# 假设我们的主机名为：A，用户名：ddc，ip：192.168.0.1# 想要无密SSH登陆的主机名为：B， 用户名：ubuntu，ip：192.168.0.2 # 首先，我们使用A中的ddc用户拷贝 " ~/.ssh/id_rsa.pub " 到B的 " /home/ubuntu/tmp/ " 目录下scp ~/.ssh/id_rsa.pub ubuntu@192.168.0.2:/home/ubuntu/tmp# 这里的ip也可以换为主机名 # 然后，ssh登陆B，将 " /home/ubuntu/tmp/id_rsa.pub " 追加到 " ~/.ssh/authorized_keys " 中去。cat /home/ubuntu/tmp/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 现在，我们就可以在A中使用SSH无密登陆到B的ubuntu用户了，同理如果想无密登陆其它的主机都可以使用此方法。需要注意的是配置ubuntu集群时需要Master和Slave可以互相SSH无密登陆。 参考链接：http://www.cnblogs.com/lijingchn/p/5580263.html 配置待部署主机在这部分主要完成以下三件事情： 为本地的 hexo_blog 配置一个部署静态文件的远程仓库。 配置 Nginx 托管博客文件目录。 配置远程仓库自动更新到博客文件目录的钩子。 创建私有 Git 仓库在/var/repo/下，创建一个名为hexo_static的裸仓库（bare repo）。 如果没有/var/repo目录，需要先创建；然后修改目录的所有权和用户权限。 创建文件夹123sudo mkdir /var/repo/sudo chown -R $USER:$USER /var/repo/sudo chmod -R 755 /var/repo/ 然后，执行如下命令： 创建裸仓库12cd /var/repo/git init --bare hexo_static.git 这一步主要是初始化裸仓库，只有初始化之后我们后面才可以向这个仓库中添加代码。 配置 Nginx 托管文件目录接下来，创建/var/www/hexo目录，用于 Nginx 托管。 创建文件目录123sudo mkdir -p /var/www/hexosudo chown -R $USER:$USER /var/www/hexosudo chmod -R 755 /var/www/hexo 然后去修改Nginx的默认配置，这个文件夹因人而异，我的是在： 1sudo vim /etc/nginx/conf.d/default.conf 将其中的 root 指令指向 /var/www/hexo 目录 修改配置123456789...server &#123; listen 80 default_server; #域名备案完成后需要修改这里 listen [::]:80 default_server ipv6only=on; root /var/www/hexo; # 需要修改的部分 index index.html index.htm;... 最后，重启 Nginx 服务，使得改动生效。sudo service nginx restart直接把nginx服务加到系统启动项中。 创建 Git 钩子接下来，在服务器上的裸仓库 hexo_static 创建一个钩子，在满足特定条件时将静态 HTML 文件传送到 Web 服务器的目录下，即 /var/www/hexo。 在自动生成的 hooks 目录下创建一个新的钩子文件： 1vim /var/repo/hexo_static.git/hooks/post-receive 在该文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。 123#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f 保存并退出文件，并让该文件变为可执行文件。 1sudo chmod +x /var/repo/hexo_static.git/hooks/post-receive 至此，服务端的配置基本结束。 修改hexo设置完成服务器端的设置之后只需要对hexo站点配置文件进行修改就可以实现部署到服务器端了。修改博客根录下的配置文件1234deploy: type: git repo: root@云服务器的IP地址:/var/repo/hexo_static branch: master 运行下面命令部署 部署12hexo cleanhexo g -d 参考链接：http://qiuqingyu.cn/2017/03/23/将hexo部署到腾讯云上/]]></content>
      <categories>
        <category>Hexo博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Nginx</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章添加emoji表情和自定义表情包]]></title>
    <url>%2F2018%2F01%2F12%2FHexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0emoji%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[在自己的网站上添加emoji和自定义表情包 首先安装相应的插件cd到博客文件根目录~/blog1npm install hexo-filter-github-emojis --save 到站点的配置文件的适当位置插入~/blog/_config.yml1234567githubEmojis:enable: true- className: github-emoji+ idName: github-emojiunicode: falsestyles:localEmojis: 这里需要我们将所有的className替换为idName ~/blog/node_modules/hexo-filter-github-emojis/index.js123456789101112131415161718 var codepoints = emojis[emojiName].codepoints if (options.unicode &amp;&amp; codepoints) &#123; codepoints = codepoints.map(function (code) &#123; return '&amp;#x' + code + ';' &#125;).join('') return '&lt;span id="' + options.idName + '" ' + styles +- ' title="' + emojiName +- '" data-src="' + emojis[emojiName].src ++ ' data-src="' + emojis[emojiName].src + '"&gt;' + codepoints + '&lt;/span&gt;' &#125; else &#123; return '&lt;img id="' + options.idName + '" ' + styles +- ' title="' + emojiName + '" alt="' + emojiName + '" src="' ++ ' alt="' + emojiName + '" src="' + emojis[emojiName].src + '" height="20" width="20" /&gt;' &#125; 因为Next主题的一些样式会干扰emoji图片显示效果，所以要在customs.styl中添加代码： ~/blog/themes/next/source/css/_custom/custom.styl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 里面的 color 值请改为你博客的！ */// 自定义emoji样式img#github-emoji &#123; margin: 0px; padding: 0px; display: inline !important; vertical-align: text-bottom; border: none; cursor: text; text-decoration: none; box-shadow: none;&#125;// 文章超链接样式（为emoji特设）.post-body a &#123; color: rgb(80, 115, 184); border-bottom: none; text-decoration: underline;&#125;.post-body a:hover &#123; color: rgb(161, 102, 171); border-bottom: none; text-decoration: underline;&#125;// 标签云页面超链接样式（为emoji特设）.tag-cloud a &#123; color: rgb(80, 115, 184); border-bottom: 1px solid rgb(80, 115, 184); text-decoration: none;&#125;.tag-cloud a:hover &#123; color: rgb(161, 102, 171); border-bottom: 1px solid rgb(161, 102, 171); text-decoration: none;&#125;// 文章元数据中categories的样式（为emoji特设）a.categories &#123; color: rgb(80, 115, 184); border-bottom: none; text-decoration: underline;&#125;a.categories:hover &#123; color: rgb(161, 102, 171); border-bottom: none; text-decoration: underline;&#125;// tabs标签（为emoji特设）.post-body .tabs ul.nav-tabs li.tab a &#123; text-decoration: none;&#125;// 图片下方标题设置（为emoji特设）a.fancybox&#123; &#125;// 按钮样式（为emoji特设）.btn &#123; color: #fff !important; text-decoration: none !important; border: 2px solid #222 !important;&#125;.btn:hover &#123; color: #222 !important;&#125; 结果 添加自定义表情包1&lt;img id="github-emoji" src="http://img.dpsdp.com/18-1-12/41478602.jpg" height="100" width="150" /&gt; 比如皮卡丘的这个表情]]></content>
      <categories>
        <category>Hexo博客搭建</category>
        <category>Hexo优化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+markdown优雅写博客]]></title>
    <url>%2F2018%2F01%2F11%2FHexo-markdown%E4%BC%98%E9%9B%85%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用hexo内置的一些样式加上markdown语法和FontAwesome字体语法，来进行博客写作，此文章主要介绍三种方法中常用的语法。 hexo 常用的内置的样式引用样式1234&#123;% cq %&#125;行到水穷处，坐看云起时。**王维**&#123;% endcq %&#125; 行到水穷处，坐看云起时。王维 此外还有这种代码也能实现此功能 实现的语法123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 简单居中 代码部分： 实现文字居中的语法1&lt;center&gt;行到水穷处，坐看云起时&lt;/center&gt; 效果： 行到水穷处，坐看云起时 其他内置标签:http://theme-next.iissnan.com/tag-plugins.html Next主题自带的note样式标签本样式代码： 1&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; 本样式代码： 1&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt; 本样式代码： 1&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt; 本样式代码： 1&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; 本样式代码： 1&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt; 本样式代码： 1&lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; 不使用图标可以在代码中修改，比如： 本样式代码： 1&lt;div class=&quot;note danger no-icon&quot;&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; 也可以修改默认设置，在主题配置文件下修改： 文件位置~/blog/themes/next/_config.yml12345678910# Note tag (bs-callout).note:# 风格 style: flat# 要不要图标- icons: false+ icons: true# 圆角矩形 border_radius: 3 light_bg_offset: 0 这里顺便说一下代码块语法代码块语法前后各用三个`包围， 使用方法： Usage123```[language] [title] [url] [link-text]代码``` 这里有一种代码语言为diff，可以在代码中添加+，-号，而且-是红色，+是绿色。比如： 修改代码块标题样式，在~/blog/themes/next/source/css/_custom/custom.styl添加1234567891011+// 文章```代码块顶部样式+.highlight figcaption &#123;+ margin: 0em;+ padding: 0.5em;+ background: #eee;+ border-bottom: 1px solid #e9e9e9;+&#125;+.highlight figcaption a &#123;+ color: rgb(80, 115, 184);+&#125;- //演示减号- 主题自带的label标签文件位置：~/blog/themes/next/_config.yml12# Label tag.label: true 效果如下（@ 前面的是label的名字，后面的是要显示的文字）： 前面的是label的名字，后面的是要显示的文字123456&#123;% label default@default %&#125;&#123;% label primary@primary %&#125;&#123;% label success@success %&#125;&#123;% label info@info %&#125;&#123;% label warning@warning %&#125;&#123;% label danger@danger %&#125; default primary success info warning danger 选项卡tabs标签直接上代码和效果吧 源码1234567891011&#123;% tabs 选项卡, 2 %&#125; 名字为选项卡，默认在第二个选项卡，如果是-1则隐藏&lt;!-- tab --&gt;**这是选项卡 1** 哈哈哈&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～，哈哈哈哈哈哈哈哈，&#123;% label info@好无聊啊我…… %&#125;&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 选项卡 1选项卡 2选项卡 3这是选项卡 1 哈哈哈 这是选项卡 2 这是选项卡 3 哇，你找到我了！φ(≧ω≦*)♪～，哈哈哈哈哈哈哈哈，好无聊啊我…… -1的情况： 选项卡 1选项卡 2选项卡 3这是选项卡 1 哈哈哈 这是选项卡 2 这是选项卡 3 哇，你找到我了！φ(≧ω≦*)♪～，哈哈哈哈哈哈哈哈，好无聊啊我…… 自定义标签名 自定义标签名1234567891011&#123;% tabs Fourth unique name %&#125;&lt;!-- tab Solution 1 --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 2 --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 3 --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; Solution 1Solution 2Solution 3This is Tab 1. This is Tab 2. This is Tab 3. 用标签代替选项卡名字 Tab tag with icons only1234567891011&#123;% tabs Fifth unique name %&#125;&lt;!-- tab @text-width --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab @amazon --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab @bold --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; This is Tab 1. This is Tab 2. This is Tab 3. 给标签添加超链接 代码如下： Tab tag permalinks test123456789101112131415161718192021222324252627282930313233Permalink for &gt; [Tab one](#tab-one).Permalink for &gt; [Tab one 1](#tab-one-1).Permalink for &gt; [Tab one 2](#tab-one-2).Permalink for &gt; [Tab one 3](#tab-one-3).Permalink for &gt; [Tab two](#tab-two).Permalink for &gt; [Tab two 1](#tab-two-1).Permalink for &gt; [Tab two 2](#tab-two-2).Permalink for &gt; [Tab two 3](#tab-two-3).&#123;% tabs Tab one %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;&#123;% tabs Tab two %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; Permalink for &gt; Tab one.Permalink for &gt; Tab one 1.Permalink for &gt; Tab one 2.Permalink for &gt; Tab one 3. Permalink for &gt; Tab two.Permalink for &gt; Tab two 1.Permalink for &gt; Tab two 2.Permalink for &gt; Tab two 3. Tab one 1Tab one 2Tab one 3This is Tab 1. This is Tab 2. This is Tab 3. Tab two 1Tab two 2Tab two 3This is Tab 1. This is Tab 2. This is Tab 3. 标签里带有其他标签 Tab tag with other tags1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123;% tabs Tags %&#125;&lt;!-- tab --&gt;**This is Tab 1.**1. One2. Two3. ThreeTabbed code block:nano /etc&#123;% code %&#125;code block tagcode block tagcode block tag&#123;% endcode %&#125;&#123;% note default %&#125;Note default tag.&#123;% endnote %&#125;&#123;% youtube A1Qb4zfurA8 %&#125;&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.*** Five* Six* Seven&#123;% note primary %&#125;&#123;% youtube rX3W5evpeJE %&#125;&#123;% endnote %&#125;&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&#123;% note success %&#125;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc.Sed egestas, ante et vulputate volutpat, eros pede semper est, vitae luctus metus libero eu augue. Morbi purus libero, faucibus adipiscing, commodo quis, gravida id, est. Sed lectus. Praesent elementum hendrerit tortor. Sed semper lorem at felis. Vestibulum volutpat, lacus a ultrices sagittis, mi neque euismod dui, eu pulvinar nunc sapien ornare nisl. Phasellus pede arcu, dapibus eu, fermentum et, dapibus sed, urna.Morbi interdum mollis sapien. Sed ac risus. Phasellus lacinia, magna a ullamcorper laoreet, lectus arcu pulvinar risus, vitae facilisis libero dolor a purus. Sed vel lacus. Mauris nibh felis, adipiscing varius, adipiscing in, lacinia vel, tellus. Suspendisse ac urna. Etiam pellentesque mauris ut lectus. Nunc tellus ante, mattis eget, gravida vitae, ultricies ac, leo. Integer leo pede, ornare a, lacinia eu, vulputate vel, nisl.&#123;% endnote %&#125;&lt;!-- endtab --&gt;&#123;% endtabs %&#125; Tags 1Tags 2Tags 3This is Tab 1. One Two Three Tabbed code block: nano /etc 123code block tagcode block tagcode block tag Note default tag. This is Tab 2. Five Six Seven This is Tab 3. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Phasellus hendrerit. Pellentesque aliquet nibh nec urna. In nisi neque, aliquet vel, dapibus id, mattis vel, nisi. Sed pretium, ligula sollicitudin laoreet viverra, tortor libero sodales leo, eget blandit nunc tortor eu nibh. Nullam mollis. Ut justo. Suspendisse potenti. Pellentesque fermentum dolor. Aliquam quam lectus, facilisis auctor, ultrices ut, elementum vulputate, nunc. Sed egestas, ante et vulputate volutpat, eros pede semper est, vitae luctus metus libero eu augue. Morbi purus libero, faucibus adipiscing, commodo quis, gravida id, est. Sed lectus. Praesent elementum hendrerit tortor. Sed semper lorem at felis. Vestibulum volutpat, lacus a ultrices sagittis, mi neque euismod dui, eu pulvinar nunc sapien ornare nisl. Phasellus pede arcu, dapibus eu, fermentum et, dapibus sed, urna. Morbi interdum mollis sapien. Sed ac risus. Phasellus lacinia, magna a ullamcorper laoreet, lectus arcu pulvinar risus, vitae facilisis libero dolor a purus. Sed vel lacus. Mauris nibh felis, adipiscing varius, adipiscing in, lacinia vel, tellus. Suspendisse ac urna. Etiam pellentesque mauris ut lectus. Nunc tellus ante, mattis eget, gravida vitae, ultricies ac, leo. Integer leo pede, ornare a, lacinia eu, vulputate vel, nisl. 参考文章链接 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 Hexo Theme Next Test]]></content>
      <categories>
        <category>Hexo博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo部分优化]]></title>
    <url>%2F2018%2F01%2F10%2FHexo%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[打造个性超赞博客基于Hexo+NexT优化 fontawesom 字体的使用 铅笔 上传 下载 对应的代码为123- &lt;i class="fa fa-pencil"&gt;&lt;/i&gt; 铅笔- &lt;i class="fa fa-cloud-upload"&gt;&lt;/i&gt; 上传- &lt;i class="fa fa-download"&gt;&lt;/i&gt; 下载 在比如： 下载 下载变大 33% 下载两倍大 代码如下： 123- &lt;i class="fa fa-download"&gt;&lt;/i&gt; 下载- &lt;i class="fa fa-download fa-lg"&gt;&lt;/i&gt; 下载变大 33%- &lt;i class="fa fa-download fa-2x"&gt;&lt;/i&gt; 下载两倍大 动态图标 Loading… Loading… Loading… Loading… Loading… 代码： 1234567891011121314&lt;i class="fa fa-spinner fa-spin fa-3x fa-fw"&gt;&lt;/i&gt;&lt;span class="sr-only"&gt;Loading...&lt;/span&gt;&lt;i class="fa fa-circle-o-notch fa-spin fa-3x fa-fw"&gt;&lt;/i&gt;&lt;span class="sr-only"&gt;Loading...&lt;/span&gt;&lt;i class="fa fa-refresh fa-spin fa-3x fa-fw"&gt;&lt;/i&gt;&lt;span class="sr-only"&gt;Loading...&lt;/span&gt;&lt;i class="fa fa-cog fa-spin fa-3x fa-fw"&gt;&lt;/i&gt;&lt;span class="sr-only"&gt;Loading...&lt;/span&gt;&lt;i class="fa fa-spinner fa-pulse fa-3x fa-fw"&gt;&lt;/i&gt;&lt;span class="sr-only"&gt;Loading...&lt;/span&gt; markdown 语法补充加入超链接 markdwon语法 1[markdwon语法](https://kennylee26.gitbooks.io/markdown/content/index.html) 居中 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ 代码：123456&#123;% cq %&#125;人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！&#123;% endcq %&#125; hexo next 主题自带功能info1&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; default 1&#123;% label default@default %&#125; primary 1&#123;% label primary@primary %&#125; 更多NexT主题自带的标签样式， 请点击：http://theme-next.iissnan.com/tag-plugins.html 文章模板部分解释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* ！！！！！！！！！！** 每一项的 : 后面均有一个空格** 且 : 为英文符号** ！！！！！！！！！！*/title:/* 文章标题，可以为中文 */date:/* 建立日期，如果自己手动添加，请按固定格式** 就算不写，页面每篇文章顶部的发表于……也能显示** 只要在主题配置文件中，配置了 created_at 就行** 那为什么还要自己加上？** 自定义文章发布的时间*/updated:/* 更新日期，其它与上面的建立日期类似** 不过在页面每篇文章顶部，是更新于……** 在主题配置文件中，是 updated_at*/permalink:/* 若站点配置文件下的 permalink 配置了 title** 则可以替换文章 URL 里面的 title（文章标题）*/categories:/* 分类，支持多级，比如：- technology- computer- computer-aided-art则为technology/computer/computer-aided-art（不适用于 layout: page）*/tags:/* 标签** 多个可以这样写[标签1,标签2,标签3]** （不适用于 layout: page）*/description:/* 文章的描述，在每篇文章标题下方显示** 并且作为网页的 description 元数据** 如果不写，则自动取 &lt;!-- more --&gt;** 之前的文字作为网页的 description 元数据** 建议每篇文章都务必加上！*/keywords:/* 关键字，并且作为网页的 keywords 元数据** 如果不写，则自动取 tags 里的项** 作为网页的 keywords 元数据*/comments:/* 是否开启评论** 默认值是 true** 要关闭写 false*/layout:/* 页面布局，默认值是 post，默认值可以在** 站点配置文件中修改 default_layout** 另：404 页面可能用到，将其值改为 false*/type:/* categories，目录页面** tags，标签页面** picture，用来生成 group-pictures** quote？** https://reuixiy.github.io/uncategorized/2010/01/01/test.html*/photos:/* Gallery support，用来支持画廊 / 相册，用法如下：- photo_url_1- photo_url_2- photo_url_3https://reuixiy.github.io/uncategorized/2010/01/01/test.html*/link:/* 文章的外部链接** https://reuixiy.github.io/uncategorized/2010/01/01/test.html*/image:/* 自定义的文章摘要图片，只在页面展示，文章内消失** 此项只有参考本文 5.14 节配置好，否则请勿添加！*/sticky:/* 文章顺序调整** 越大越靠上*/password:/* 文章密码，此项只有参考教程：** http://shenzekun.cn/hexo的next主题个性化配置教程.html** 第 24 节，配置好，否则请勿添加！** 发现还是有 bug 的，就是右键在新标签中打开** 然后无论是否输入密码，都能看到内容*/ 参考文章 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化]]></content>
      <categories>
        <category>Hexo博客搭建</category>
        <category>Hexo优化</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光环形器的原理]]></title>
    <url>%2F2018%2F01%2F10%2F%E7%8E%AF%E5%BD%A2%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[这篇文章首先介绍旋光效应，分别有自然旋光和磁致旋光，然后介绍PBS(偏振分束棱镜)的原理，最后介绍环形器的组成及原理 环形器的原理旋光效应旋光效应：平面偏振光在某些各向异性介质中沿光轴传播时，其震动方向会随着传播距离增大而连续旋转的现象 自然旋光和磁致旋光的区别 自然旋光介质具有互易性，入射平面偏振光的偏振面旋转方向与光的传播方向无关，迎着光看，左旋介质总使光的偏振面逆时针旋转，右旋介质总是光的偏振面顺时针旋转。因此当透射光波由于反射而在此经过自然旋光介质时，其偏振面将回到初始位置。 磁光介质具有互易性，入射平面偏振光的偏振面旋转方向与磁场的正方向有关。迎着光看，当光波沿磁场的正方向传播时，偏振面逆时针旋转；当光波沿磁场的负方向传播时，偏振面顺时针旋转。如果顺着磁场方向看，则光的振动面总是顺时针旋转，这类物质称为正旋体。另外也有一些物质是负旋体。因此，当透射光波由于反射而再次反向穿过磁光介质时，其偏振面将相对于初始方向旋转 $2\phi$ 角 偏振分束棱镜（PBS）偏振分光棱镜能把入射的非偏振光分成两束垂直的线偏光。其中P偏光完全通过，而S偏光以45度角被反射，出射方向与P光成90度角。此偏振分光棱镜由一对高精度直角棱镜胶合而成，其中一个棱镜的斜边上镀有偏振分光介质膜 环形器结构图 环形器从一端口能够从二端口出 从二端口进则只能从三端口出 空芯高双折射光纤为了提高耐受度，进而提高放大的峰值功率]]></content>
      <categories>
        <category>老本行</category>
      </categories>
      <tags>
        <tag>Laser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yb速率方程近似等效为二能级系统]]></title>
    <url>%2F2018%2F01%2F08%2FYb%E9%80%9F%E7%8E%87%E6%96%B9%E7%A8%8B%E8%BF%91%E4%BC%BC%E7%AD%89%E6%95%88%E4%B8%BA%E4%BA%8C%E8%83%BD%E7%BA%A7%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[此文章介绍Yb离子的速率方程，代码部分利用python语言。介绍了谱线加宽，线型函数以及速率方程 先上部分代码12345678910import numpy as np import matplotlib.pyplot as pltplt.rc('font',family='Microsoft YaHei',size=14)##参数设定h=6.626e-34c=3e8core=10e-6A=np.pi*(core/2)**2lamda=975e-9tau=2e-3 Yb离子的吸收和发射截面123456789101112131415def cross(lam): '''labmda是Yb离子的波长，单位nm''' # if lam&lt;=1: # lam=lam*1e9 sig_as=(180*np.exp(-(((lam-950)/70)**2)) + \ 360*np.exp(-(((lam-895)/24)**2)) +\ 510*np.exp(-(((lam-918)/22)**2)) + \ 160*np.exp(-(((lam-971)/12)**2)) + \ 2325*np.exp(-(((lam-975)/4)**2)))*1e-27; sig_es=(2325*np.exp(-(((lam-975)/4)**2)) + \ 160*np.exp(-(((lam-978)/12)**2)) + \ 340*np.exp(-(((lam-1025)/20)**2)) + \ 175*np.exp(-(((lam-1050)/60)**2)) + \ 150*np.exp(-(((lam-1030)/90)**2)))*1e-27; return sig_as,sig_es 12345678910111213wave=np.linspace(850,1100,10000)(A,B)=cross(wave)plt.figure(figsize=(9,6),dpi=300)plt.plot(wave,A*1e24,'b--',linewidth=3,label='吸收截面')plt.plot(wave,B*1e24,'r-',linewidth=3,label='发射截面')plt.xlabel('波长/nm',fontsize=18)plt.ylabel('横截面积/($10^&#123;-20&#125;cm^2$)',fontsize=18)plt.ylim((0,3))plt.xlim((850,1100))plt.legend(loc=1)plt.grid(True)plt.savefig('吸收和发射截面.jpg')plt.show() 吸收I(z)=I_0exp(-N_0\sigma_{12}z)=I_0exp(-\alpha z)增益I(z)=I_0exp(N_{inv}\sigma_{21}z)=I_0exp(gz)=G_0I_0$N_{inv}$为反转粒子数小信号增益$G_0=exp(N_{inv}\sigma_{21}L)$$g=ln(\frac{I(z)}{I_0})=N_{inv}\sigma_{21}$ 假设增益为80dB/m可以求得$10*lg(\frac{I(z)}{I_0})=80$,则：$ln(\frac{I(z)}{I_0})=\frac{\frac{80}{10}}{0.434}$，则$N_{inv}\sigma_{21}=\frac{\frac{80}{10}}{0.434}$ 可以求得$N_{inv}$ 假设吸收为80dB/m可以求得$10*lg(\frac{I_0}{I(z)})=80$,则：$ln(\frac{I_0}{I(z)})=\frac{\frac{80}{10}}{0.434}$，则$N_0\sigma_{12}=\frac{\frac{80}{10}}{0.434}$ 可以求得$N_0$ 谱线加宽和线型函数概念当不考虑原子能级之间的宽度时，自发辐射是单色的，辐射的全部功率都集中在一个单一频率上 \nu={\frac{E_2-E_1}{h}}单位体积物质内的原子自发辐射功率为： P=\left( {\frac{dn_{21}}{dt}} \right)_{sp}h\nu =n_2A_{21}h\nu根据Heisenberg测不准关系得谱宽\delta P \delta x=\delta E \delta t=\frac{h}{2\pi}若能级无限窄则能级具有无限长的寿命若能级有有限自发辐射寿命$\tau$&emsp;则能级具有有限宽度$\delta E$ \delta E=\frac{h}{2\pi\tau}=\frac{h}{2\pi}A_u上下能级宽度分别为： \delta E_u=E_{uM}-E_{um}和\delta E_l=E_{lM}-E_{lm}自发辐射的中心频率为： \nu_0=\frac{E_{u0}-E_{l0}}{h}上边频为$v_+=\frac{E_{uM}-E_{lm}}{h}$&emsp;下边频为$v_-=\frac{E_{um}-E_{lM}}{h}$谱线宽度为 \Delta\nu=\nu_+-\nu_-= \frac{1}{h} \left( { \delta E_u+\delta E_l } \right) = \frac{1}{2\pi} \left( {\sum\limits_i {A_{ui} + \sum\limits_j {A_{lj}} } } \right) 线型函数由于谱线加宽，自发辐射的功率随频率有一定的分布，用$P(\nu)$来表示。分布在$\nu~\nu+d\nu$范围内的辐射功率为$P(\nu)d\nu$ 则自发辐射的总功率为： P=\int_{ - \infty }^{ + \infty } {P\left( \nu \right)} \cdot d\nu引入线型函数$g(\nu)$,定义为 g(\nu)=\frac{p(\nu)}{P}g(v)量纲为[s]也可以定义为： g(\nu)=\frac{I(\nu)}{I}其中$I(\nu)=\frac{P(\nu)}{A}$—单位面积上的辐射功率线型函数的归一化条件： \int_{ - \infty }^{ + \infty } {g\left( \nu \right)} \cdot d\nu = 1谱线宽度半全高宽度（FWHM）最大值的一半用波长差表示的线宽 \Delta\lambda=\frac{\lambda^2}{c}\Delta\nu激光中常用用波数差表示的线宽 \Delta(\frac{1}{\lambda})=\frac{1}{c}\Delta\nu自然加宽\Delta\nu_N=\frac{1}{2\pi}\frac{1}{\tau}激光器的速率方程原子的自发辐射、受激辐射和受激吸收几率\left({\frac{dn_{21}}{dt}}\right)_{sp}=A_{21}n_2\left({\frac{dn_{21}}{dt}}\right)_{st}=W_{21}n_2=B_{21}\rho_\nu n_2\left({\frac{dn_{12}}{dt}}\right)_{st}=W_{121}n_2=B_{12}\rho_\nu n_1\frac{A_{21}}{B_{21}}=\frac{8\pi h\nu^3}{c^3}=n_\nu h\nug_1B_{12}=g_2B_{21}注： 黑体辐射分配到腔内每个模式上的平均能量为：E=\frac{h\nu}{e^{\frac{h\nu}{k_bT}-1}} 腔内单位体积中频率处于$\nu$附近单位频率间隔内的光波模式数$n_\nu$为：n_\nu=\frac{N_\nu}{Vd\nu}=\frac{8\pi\nu}{c^3}于是可以得到黑体辐射普朗克公式：\rho_\nu=\frac{8\pi h\nu^3}{c^3}\frac{1}{e^{\frac{h\nu}{k_bT}-1}}玻尔兹曼常数$k_b=1.38062\times10^{-23}J/K$ 光子简并度$\bar n$\bar n=\frac{E}{h\nu}=\frac{1}{e^{\frac{h\nu}{k_bT}-1}}还等于：\bar n=\frac{\rho_\nu}{\frac{8\pi h\nu^3}{c^3}}=\frac{B_{21}\rho_\nu}{A_{21}}=\frac{W_{21}}{A_{21}} 热平衡状态下满足玻尔兹曼分布：\frac{n_2}{n_1}=e^{-\frac{(E_2-E_1)}{k_bT}}修正之后的几率 g(\nu)=\frac{p(\nu)}{P}&rArr;P(\nu)=Pg(\nu)=\left({\frac{dn_{21}}{dt}}\right)_{sp}h\nu_0g(\nu)=n_2h\nu_0A_{21}g(\nu)=n_2h\nu_0A_{21}(\nu)其中：A_{21}(\nu)=A_{21}g(\nu) g(\nu)=\frac{A_{21}(\nu)}{A_{21}}B_{21}(\nu)=B_{21}g(\nu)=\frac{c^3}{8\pi h\nu^3}A_{21}(\nu)W_{21}(\nu)=B_{21}(\nu)\rho_\nu=B_{21}g(\nu)\rho_\nu表示在辐射场$\rho_\nu$作用下，总的受激辐射几率$W_{21}$中分配在频率$\nu$处单位频带内的受激辐射几率。 对于自发辐射来说，$n_2$个原子中单位时间内发生自发辐射跃迁的原子总数为： \left({\frac{dn_{21}}{dt}}\right)_{sp}=\int_{ - \infty }^{ + \infty }{n_2A_{21}(\nu)d\nu}=\int_{-\infty}^{\infty}{n_2A_{21}g(\nu)}d\nu=n_2A_{21}对于受激辐射： \left({\frac{dn_{21}}{dt}}\right)_{st}=\int_{-\infty}^{\infty}{n_2W_{21}(\nu)d\nu}=\int_{-\infty}^{\infty}{n_2B_{21}g(\nu)\rho_\nu d\nu}=n_2B_{21}\int_{-\infty}^{\infty}{g(\nu)\rho_\nu d\nu}小信号增益的计算$G_0=exp(N_{inv}\sigma_{21}L)$$E_{stor}=N_{inv}ALh\nu_{21}$ &rArr; $N_{inv}=\frac{E_{stor}}{ALh\nu_{21}}$ 这里A:area of beam$G_0=exp(\frac{E_{stor}}{A}\frac{\sigma_{21}}{h\nu_{21}})$Energy fluence =energy per unit areaDefine: “store fluence” :$\Gamma_{stor}=\frac{E_{stor}}{A}$ “saturation fluence”: $\Gamma_{sat}=\frac{h\nu_{21}}{\sigma_{21}}$ G_0=exp(\frac{\Gamma_{stor}}{\Gamma_{sat}})123gamma_sat=h*c/cross(lamda)[1] #饱和光通量print(gamma_sat)0.0759892291095 例子 泵浦激光的单脉冲能量10mJ，计算到晶体的增益$G_0=5$ Pump laser has 10mJ per pulse, calculate spot size in crystal for $G_0=5$ Ti:sapphire:&emsp;$\lambda_{21}=800nm,h\nu=1.55eV=2.48e-19J$&emsp;$\sigma_{21}=2.8e-19cm^2$&emsp;$\Gamma_{sat}=0.85J/cm^2$则：$\Gamma_{stor}=\Gamma_{sat}ln[G_0]=1.37J/cm^2$For pulse duration of 10ns, pump intensity is:$I=1.37\times10^8W/cm^2$$A=7.3\times10^{-3}cm^2$$w_0=480um$ 1234w0=480e-3A=np.pi*w0**2print(A)0.7238229473870883 二能级系统平衡下有：${\frac{dN_1}{dt}}={-\frac{dN_2}{dt}}$&emsp;$\Delta N=N_1-N_2$&rArr;$\Delta N=\frac{N_t}{1+2W\tau_{21}}$二能级系统说明N1永远大于N2，不可能出现粒子数反转的情况这里$N_t:N_{total}=N_1+N_2$$W=W_{21}=W_{12}=\rho_{\nu} B_{21}$$A_{21}=1/{\tau_{21}}$ 传播过程存在初始信号有：初始泵浦（在一段距离满足泵浦饱和）、初始信号（开始很小，不存在反转粒子数饱和） 传播过程分析: 第一段传播距离：已知初始泵浦，可求得小信号反转粒子数，然后可以求出增加的小信号光强，可以求出吸收的泵浦光，可得剩余泵浦光； 第二段传播距离：因为信号光在增强，泵浦吸收一直饱和，所以泵浦光单位长度吸收提高。信号光强增加，远小于饱和光强，反转粒子数浓度减少的较慢。此外，泵浦光功率也在逐渐减小，也会导致反转粒子数浓度减少。由于W21随着光强增大而增加，大于反转粒子数的影响，因此信号光增加的速率变快。 第三段传播距离：信号光强达到饱和光强，反转粒子数急剧减小，信号光强增加变缓，直到泵浦光被吸收完毕。然后基本保持不变。增益饱和是指信号光强增加到饱和光强增益减小的现象。 另一种第三段传播情况，信号光还未达到饱和光强，泵浦光就已经被吸收完毕，这种情况是：泵浦光被吸收的越来越快（因为信号光在增加，反转粒子数消耗的更快，）信号光增加的越来越快，因为W21在增加比反转粒子数减少的更快。当泵浦光到饱和吸收功率附近，泵浦吸收小于饱和吸收功率，且逐渐减小，泵浦光功率减少速度逐渐变慢，直到为零。信号光功率一直增加，直到泵浦光完全被吸收。]]></content>
      <categories>
        <category>老本行</category>
      </categories>
      <tags>
        <tag>Laser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群速度色散]]></title>
    <url>%2F2018%2F01%2F08%2F%E7%BE%A4%E9%80%9F%E5%BA%A6%E8%89%B2%E6%95%A3%2F</url>
    <content type="text"><![CDATA[主要介绍色散的基础知识，以及二阶三阶色散系数的物理意义。以及群速度色散的计算方法 色度色散所谓正色散就是随着波长的增大，折射率减小．因此色散是减小的．相反就是负色散 当一束电磁波与电介质的束缚电子发生相互作用时，介质的响应通常与光波频率$\omega $，这种特性称为色度色散，简称色散，它表明折射率$n(\omega )$对频率的依赖关系。一般来说，色散的起源与介质通过束缚电子的振荡吸收电磁辐射的特征谐振频率有关，当远离介质谐振频率时，折射率$n(\omega )$可用赛尔迈耶尔公式很好地近似。 {n^2}(\omega ) = 1 + \sum\limits_{j = 1}^m {B_j\omega _j^2 \over {\omega _j^2 - \omega ^2}}式中，$\omega_j$是谐振频率，$B_j$为第j个谐振的强度。 光纤的色散效应光纤的色散效应是通过在脉冲频谱的中心频率$\omega_0$附近将模传播常数$\beta$展开成泰勒级数来解释的： \beta \left( \omega \right) = n\left( \omega \right){\omega \over c} = {\beta _0} + {\beta _1}\left( {\omega - {\omega _0}} \right) + {1 \over 2}{\beta _2}\left( {\omega - {\omega _0}} \right) + \cdots式中：{\beta _m} = {\left( {d^m\beta \over {d\omega ^m}} \right)_{\omega = \omega _0}},\left( {m = 0,1,2 \cdots } \right) 参量$\beta_1$和$\beta_2$与折射率$n(\omega)$有关，它的关系可由下式得到： {\beta _1} = {1 \over {v_g}} = {n_g \over c} = {1 \over c}\left( {n + \omega dn \over {d\omega }} \right){\beta _2} = {1 \over c}\left( {2dn \over {d\omega } + \omega {d^2n \over {d\omega ^2}}} \right)式中$n_g$是群折射率，$v_g$是群速度。 其中$v_g={c \over n_g}$，$\beta_2$是群速度色散参量。实际情况用色散参量$D={d \beta_1\over d{\lambda}}$，他和$\beta_2$及n的关系如下： D={d\beta_1 \over d\lambda}=-{2\pi c \over {\lambda^2}}\beta^2=-{\lambda \over c}{d^2n\over {d\lambda^2}}注：$\beta_2$的单位是：$ps^2/km$，$D$的单位是：$ps/(km\cdot nm)$ $\beta_2=0$的波长$\lambda_D$为零色散波长。若波长$\lambda&lt;\lambda_D$则为正常色散区，此时长波长传输的快 光栅压缩对 单向传输一次闪耀光栅满足 sin(\gamma-\theta)+sin(\gamma)=m\frac{\lambda}{d}这里m=1这里$\gamma为入射角,\theta为1级衍射角$可以得到：cos(\gamma-\theta)=\sqrt{1-sin^2(\gamma-\theta)}=\sqrt{1-(\frac{\lambda}{d}-sin(\gamma))^2}这里$d=1/N$N为线对密度比如thorlabs有光栅为1200/mm两光栅的垂直距离为G光程P&rArr;Q有： P(\omega)=b[1+cos(\theta)]=\frac{G}{cos(\gamma-\theta)}[1+cos(\theta)]相位可以表示为： \phi(\omega)=-\beta(\omega) z=-[\frac{\omega P}{c}-\frac{2\pi G}{d}tan(\gamma-\theta)]即在出射的振幅表达式 U(z,t)=U(0,t)*exp(j\phi)=U(0,t)*exp(-j\beta z) 对于光纤只考虑 $ \beta_2 $ 时有： U(z,\omega)=U(0,\omega)exp(\frac{1}{2}\beta_2\omega^2z)对于光栅对只考虑$\frac{\partial^2\phi(\omega)}{\partial\omega^2}$时 U(z,\omega)=U(0,\omega)exp(-\frac{1}{2}\frac{\partial^2\phi(\omega)}{\partial\omega^2}\omega^2)一阶导数：\frac{\partial\phi(\omega)}{\partial\omega}=-\frac{P}{c}二阶导数：\frac{\partial^2\phi(\omega)}{\partial\omega^2}=\frac{4\pi^2cG}{d^2\omega^3cos^3(\gamma-\theta)}\frac{\partial^2\phi(\omega)}{\partial\omega^2}=\frac{4\pi^2cG}{d^2\omega^3[1-(\frac{\lambda}{d}-sin(\gamma))^2]^{3/2}}三阶导数：\frac{\partial^3\phi(\omega)}{\partial\omega^3}=-\frac{12\pi^2cG}{d^2\omega^4cos^3(\gamma-\theta)}\left[{1+\left({\frac{2\pi c}{\omega d}}\right)\frac{sin(\gamma-\theta)}{cos^2(\gamma-\theta)}}\right]我们将相位在$\omega_0$处进行泰勒展开: \phi(\omega)=\phi_0-\tau_0(\omega-\omega0)+\frac{1}{2}\frac{1}{\mu}(\omega-\omega0)^2+\sigma(\omega-\omega0)^3+O(\omega-\omega0)^4这里： \frac{1}{\mu } = {\left. {\frac{\partial ^2\phi (\omega )}{\partial \omega ^2}} \right|_{\omega _0}},\sigma=\frac{1}{6}{\left. {\frac{\partial ^3\phi (\omega )}{\partial \omega ^3}} \right|_{\omega _0}}\tau(\omega)=-\frac{\partial \phi (\omega )}{\partial \omega }=\tau_0-\frac{1}{\mu}(\omega-\omega0)-3\sigma(\omega-\omega0)^2-O(\omega-\omega0)^3注： 对相位二阶求导得到群速度延迟group delay 是常数，即对所有光谱都是一样的，压缩时可以忽略 对相位二阶求导得到群速度延迟group delay 是线性的(GVD) 对相位三阶求导得到群速度延迟group delay 是非线性的的(TOD) 代码部分123456789101112import numpy as npimport matplotlib.pyplot as pltplt.rc('font',family='Microsoft YaHei',size=14)plt.rc('lines',lw=2)from scipy.fftpack import fft,ifft,fftshift,ifftshiftdef tranwave(x,y):'''x,y必须为向量或者列表'''middle_x=np.where(x==0)yPeak_Num=np.argmax(y)translat_step=yPeak_Num-middle_xy_out=[y[m] for m in np.mod(np.arange(len(y))+translat_step,len(y))]return y_out[0] 定义时间频率窗口123456789101112131415161718lamda=1030e-9c=3e8beta2=0.0246e-24 # 光纤二阶色散系数N_total=1000 # 采样率 越大的话频率的范围越宽nu0=c/lamda omega0=2*np.pi*nu0t_FWHM=300e-15 # 半极大全宽脉宽300飞秒T_0=t_FWHM/1.665 # T0 脉冲半宽度Tmax=50*T_0 # 总时间宽度脉宽的60倍 Tmin=-1*Tmaxt_signal=np.linspace(Tmin,Tmax,N_total+1)dt=t_signal[1]-t_signal[0]dF=1/(2*Tmax)F_signal=np.r_[(nu0-N_total/2*dF):(nu0+(N_total/2+1)*dF-1):dF] # 如果不减去0.1 由于精确度问题会出现F_signal长度多一omega=F_signal*2*np.pi #频率w坐标wave=c/F_signal #光谱横坐标E0=1 # 振幅Ld=(T_0)**2/abs(beta2) # 色散长度 带啁啾初始脉冲二阶色散演化12345678910111213141516171819202122C=2 # 啁啾系数beta2=-0.0246e-24 #负色散消啁啾Ld=(T_0)**2/abs(beta2)z=Ld*(1*abs(C)/(1+C**2)) # 消啁啾的距离 光纤长度E_chirped=E0*np.exp(-(1+1j*C)/2*(t_signal/T_0)**2) # 带啁啾初始脉冲U_chirped=abs(E_chirped)F_chirped=ifftshift(ifft(E_chirped)) #初始光谱F_cz=F_chirped*np.exp(1j/2*beta2*z*(omega-omega0)**2)FU_cz=abs(F_cz)E_cz=(fft(F_cz))U_cz=abs(E_cz)plt.plot(t_signal/T_0,U_chirped/max(U_chirped),'b-')plt.plot(t_signal/T_0,U_cz/max(U_cz),'r--')# plt.plot(t_signal/T_0,U_chirped,'b-')# plt.plot(t_signal/T_0,U_cz,'r--')# plt.plot(wave*1e9,abs(F_cz))# plt.xlim(1000,1060)plt.xlim(-5,5)plt.show() 啁啾脉冲的高阶色散演化12345678910111213141516171819202122232425262728293031323334353637383940C=0 # 啁啾系数beta2=1e-27 beta3=0.1e-39Ld=(T_0)**2/abs(beta2)Ld3=(T_0**3)/abs(beta3)beta2=T_0**2/Ld3z=Ld3*5 # 光纤长度E_chirped=E0*np.exp(-(1+1j*C)/2*(t_signal/T_0)**2) # 带啁啾初始脉冲U_chirped=abs(E_chirped)F_chirped=ifftshift(ifft(E_chirped)) #初始光谱##只考虑三阶色散F_cz3=F_chirped*np.exp(1j/6*beta3*z*(omega-omega0)**3)F_cz23=F_chirped*np.exp(1j*1/2*beta2*(omega-omega0)**2*z+1j/6*beta3*z*(omega-omega0)**3)FU_cz23=abs(F_cz23)**2E_cz23=(fft(F_cz23))U_cz23=abs(E_cz23)**2FU_cz3=abs(F_cz3)**2E_cz3=(fft(F_cz3))U_cz3=abs(E_cz3)**2# plt.plot(t_signal/T_0,U_chirped/max(U_chirped),'b-')# plt.plot(t_signal/T_0,U_cz/max(U_cz),'r--')plt.figure(figsize=(10,5))plt.plot(t_signal/T_0,U_chirped,'b-',label='初始无啁啾脉冲')plt.plot(t_signal/T_0,U_cz23,'g--',label='只有三阶色散')plt.plot(t_signal/T_0,U_cz3,'r:',label='二三阶色散都有,二阶色散很小时')# plt.plot(wave*1e9,abs(F_chirped))plt.xlim(-10,20)plt.ylim(0,1)plt.legend(loc='best',fontsize=14)plt.xlabel('$T/T_0$')plt.ylabel('强度')plt.xlim(-6,16)ax=plt.gca()ax.spines['bottom'].set_linewidth(2)ax.spines['left'].set_linewidth(2)ax.spines['right'].set_linewidth(2)ax.spines['top'].set_linewidth(2)plt.grid(linestyle='--',linewidth=1,color=(0.2,0.2,0.2,0.3))plt.show() 无啁啾初始脉冲经过正色散光纤产生啁啾1234567891011121314z=Ld*16 # 色散光纤长度 过长脉冲波动A_t=E0*np.exp(-2*np.log(2)*(t_signal/t_FWHM)**2) # 振幅I_t=A_t**2 # 强度分布A_f=ifftshift(ifft(A_t))A_fz=A_f*np.exp((1j*beta2*(omega-omega0)**2*z)/2)A_tz=fftshift(fft(A_fz))plt.figure()plt.plot(t_signal/T_0,tranwave(t_signal,abs(A_t)),'r-',label='初始脉冲')#plt.xlim((-5e-13,5e-13))plt.plot(t_signal/T_0,fftshift(abs(A_tz)),'b-',label='产生啁啾脉冲')plt.xlabel('$T/T_&#123;0&#125;$')plt.ylabel('强度')plt.legend()plt.show() 光栅对压缩12345678910111213141516171819202122232425G=11.5e-2 # 光栅对之间间距N=1200e3 # 每m的线对d=1/Ntheta=45/180*np.pifai2=G*lamda**3/(2*d**2*np.pi*c**2*(1-(lamda/d-np.sin(theta))**2)**(3/2))A_fzz=(fft(A_tz))A_fzzz=A_fzz*np.exp(-1j*fai2*(omega-omega0)**2/2)A_tzzz=ifftshift(ifft(A_fzzz))plt.figure()plt.plot(t_signal/t_FWHM*1.665,tranwave(t_signal,abs(A_tz)),'b-',label='带啁啾的脉冲')#plt.xlim((-5e-13,5e-13))plt.plot(t_signal/t_FWHM*1.665,(abs(A_tzzz)),'r--',label='消啁啾脉冲')plt.xlabel('T/T_0')plt.ylabel('强度')plt.axis(linewidth=3)plt.legend()plt.show()##光谱# plt.figure()# plt.plot(wave*1e9,abs(A_f),'r-')# plt.plot(wave*1e9,abs(A_fzzz),'b-')# plt.xlim((1000,1060))# plt.show() $\beta_2&gt;0$时的脉冲形状频率高的为蓝，频率低的为红$\beta_2&gt;0$时，脉冲前沿红移，脉冲后沿蓝移 12345z=5E_t_chirped=E0*np.exp(-2*np.log(2)*(t_signal/t_FWHM)**2)*np.exp(1j*(omega)*t_signal+1j*beta2*(omega-omega0)**2*z)plt.plot(t_signal,np.real(E_t_chirped))plt.xlim(-0.5e-12,0.5e-12)plt.show() 12345z=5E_t_chirped=E0*np.exp(-2*np.log(2)*(t_signal/t_FWHM)**2)*np.exp(1j*(omega)*t_signal-1j*beta2*(omega-omega0)**2*z)plt.plot(t_signal,np.real(E_t_chirped),'r-')plt.xlim(-0.5e-12,0.5e-12)plt.show() 123456789101112131415161718192021222324# 画图fig, ax1 = plt.subplots(figsize=(12,6))plt.yticks(color='g')ax1.plot(t_signal,A_t,'r-',label='振幅分布')ax1.set_xlabel('Time/s')ax1.set_ylabel('幅度', color='g')#ax1.set_xlim((-1e-12,1e-12))ax11=plt.gca()ax11.spines['left'].set_color('green')ax2 = ax1.twinx()ax2.plot(t_signal,A_tz,'b--',label='z处振幅分布')plt.yticks(color='b')ax2.set_ylabel('phase', color='b')#ax2.set_xlim((-1e-12,1e-12))ax11=plt.gca()ax11.spines['right'].set_color('b')ax1.legend(loc=2)ax2.legend(loc=5)plt.figure(figsize=(12,6))plt.plot(wave*1e9,abs(A_f))#plt.plot(wave*1e9,abs(A_fz))plt.xlim((1000,1060))plt.show() /Users/ddc/anaconda3/lib/python3.6/site-packages/numpy/core/numeric.py:531: ComplexWarning: Casting complex values to real discards the imaginary partreturn array(a, dtype, copy=False, order=order) 1234aa=np.diff(A_t)/dtaa=np.insert(aa,0,aa[0])plt.plot(t_signal,aa)plt.show()]]></content>
      <categories>
        <category>老本行</category>
      </categories>
      <tags>
        <tag>Nonlinar-optics</tag>
      </tags>
  </entry>
</search>
